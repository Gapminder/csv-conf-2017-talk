{"version":3,"sources":["webpack:///bubblechart.js","webpack:///webpack/bootstrap 39c4092c7be8eac754a0","webpack:///./src/index.js","webpack:///./src/component.js","webpack:///./src/panzoom.js","webpack:///./src/trail.js","webpack:///./~/css.escape/css.escape.js","webpack:///./src/template.html","webpack:///(webpack)/buildin/global.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_component","_component2","obj","default","VERSION_INFO","version","build","Vizabi","Tool","extend","init","placeholder","external_model","this","components","component","model","Component","_super","validate","ui","chart","lockNonSelected","time","state","parse","start","formatDate","end","default_model","autogenerate","data","conceptIndex","conceptType","entities","entities_colorlegend","entities_tags","marker_tags","space","label","hook_parent","marker","axis_x","use","axis_y","size","color","syncModels","size_label","which","scaleType","_important","extent","allow","names","marker_colorlegend","hook_rank","hook_geoshape","locale","whenHovering","showProjectionLineX","showProjectionLineY","higlightValueX","higlightValueY","labels","dragging","removeLabelBox","trails","datawarning","doubtDomain","doubtRange","presentation","panWithArrow","adaptMinMaxZoom","cursorMode","zoomOnScrolling","buttons","dialogs","popup","sidebar","moreoptions","versionInfo","_interopRequireDefault","_trail","_trail2","_panzoom","_panzoom2","_Vizabi","utils","_Vizabi$helpers","helpers","Exporter","svgexport","Labels","axisSmart","DynamicBackground","_Vizabi$iconset","iconset","iconWarn","warn","iconQuestion","question","BubbleChart","config","context","_this","template","model_expects","type","model_binds","change:time.playing","evt","original","isTouchDevice","playing","someHighlighted","clearHighlighted","change:time.start","scale","_readyOnce","splash","_trails","create","then","run","change:time.end","change:time.record","record","_export","open","element","reset","change:ui.chart.trails","toggle","redrawDataPoints","change:ui.chart.lockNonSelected","change:marker","path","indexOf","ready","yScale","xScale","updateSize","updateMarkerSizeLimits","draggingNow","approxEqual","_zoomedXYMinMax","zoomedMin","zoomedMax","playAfterZoom","pause","_panZoom","zoomToMaxMin","getZoomedMin","getZoomedMax","postponePause","change:marker.select","entityBubbles","source","_val","length","_previousVal","selectDataPoints","updateBubbleOpacity","_updateDoubtOpacity","change:marker.highlight","highlightDataPoints","titles","_formatSTitleValues","_updateSTitle","change:time.value","calculationQueue","push","toString","getFrame","frame","_frameIsValid","index","splice","frameChanged","change:ui.adaptMinMaxZoom","expandCanvas","change:marker.size.extent","redrawDataPointsOnlySize","change:marker.color","redrawDataPointsOnlyColors","change:marker.opacitySelectDim","change:marker.opacityRegular","change:ui.cursorMode","svg","chartSvg","classed","change:entities.dim","someSelected","clearSelected","sScale","cScale","xAxis","yAxis","COLOR_BLACKISH","COLOR_WHITEISH","isCanvasPreviouslyExpanded","prefix","deleteClasses","_labels","CSS_PREFIX","LABELS_CONTAINER_CLASS","LINES_CONTAINER_CLASS","LINES_CONTAINER_SELECTOR_PREFIX","_rangeBump","arg","undo","bump","activeProfile","maxRadiusPx","isArray","z1","z2","readyOnce","scrollableAncestor","findScrollableAncestor","d3","select","graph","yAxisElContainer","yAxisEl","xAxisElContainer","xAxisEl","yTitleEl","xTitleEl","sTitleEl","cTitleEl","yearEl","year","yInfoEl","xInfoEl","dataWarningEl","projectionX","projectionY","lineEqualXY","trailsContainer","bubbleContainerCrop","zoomSelection","labelsContainerCrop","bubbleContainer","labelsContainer","linesContainer","zoomRect","eventArea","bubbleCrown","selectAll","attr","location","pathname","tooltip","tooltipMobile","on","xMin","xMax","yMin","yMax","zoomer","dontFeedToState","rerun","event","metaKey","ctrlKey","root","dragRectangle","cursor","defaultPrevented","zoomByIncrement","KEY","getDimension","TIMEDIM","updateUIStrings","wScale","linear","domain","range","keys","updateIndicators","updateTime","defer","updateEntities","zoomToMarkerMaxMin","resetZoomState","zoomedMinX","getScale","zoomedMaxX","zoomedMinY","zoomedMaxY","setScales","tickFormat","getTickFormatter","duration","_reorderEntities","conceptPropsY","getConceptprops","conceptPropsX","conceptPropsS","conceptPropsC","translator","getTFunction","strings","title","Y","X","S","C","unit","yTitle","enter","append","parent","findChildByName","markerID","alignX","isRTL","alignY","updateView","xTitle","sTitle","setIcon","text","pin","rect","getBBox","coord","makeAbsoluteContext","farthestViewportElement","x","y","height","toolRect","getBoundingClientRect","chartRect","node","setHook","show","setPos","left","hide","opacity","style","getKeys","map","pointer","endTime","sortValue","sort","a","b","markers","setVisible","unselectBubblesWithNoData","getVisible","exit","remove","_bubblesInteract","mouseover","mouseout","click","onTap","stopPropagation","onLongTap","merge","_select","forEach","sizeA","sizeB","descending","ascending","trailStartTime","limits","highlightMarker","showCloseCross","isSelected","selectMarker","time_1","delayAnimations","setText","profiles","small","margin","top","right","bottom","padding","minRadiusPx","maxRadiusEm","infoElHeight","yAxisTitleBottomMargin","xAxisTitleBottomMargin","medium","large","hideSTitle","presentationProfileChanges","getActiveProfile","containerWH","getVizWidthHeight","Math","max","hypotenuse","width","setCloseCrossHeight","parseInt","resize","rangePoints","tickSizeInner","tickSizeOuter","tickPadding","tickSizeMinor","labelerOptions","toolMargin","limitMaxTickNumber","viewportLength","formatter","ySeparator","yTitleText","xSeparator","xTitleText","titleBBox","t","transform","hTranslate","translateX","translateY","_resizeDataWarning","_updateLineEqualXY","oneMeasure","min","concat","transition","dataWarningText","dataWarningWidth","remainingWidth","font","warnBB","minRadius","maxRadius","minArea","radiusToArea","maxArea","valuesNow","valuesLocked","each","selected","valueC","scaledC","find","f","valuesTrailStart","cache","scaledC0","updateLabelOnlyColor","valueS","scaledS","areaToRadius","scaledS0","updateLabelOnlyPosition","lockedFrame","_updateBubble","values","view","showhide","valueY","valueX","valueL","valueLST","hidden","ease","easeExp","easeLinear","interrupt","write","id","getUTCFullYear","fill","cx","cy","r","_updateLabel","labelX0","labelY0","labelText","updateLabel","titleS","titleC","unitS","unitC","formatterS","formatterC","isDiscrete","getColorlegendMarker","getItems","sTitleContentON","cTitleContentON","sTitleText","sTitleWidth","remainigHeight","_setTooltip","_setBubbleCrown","nonSelectedOpacityZero","glow","skipInnerFill","tooltipText","offset","xPos","yPos","xSign","ySign","xOffset","yOffset","contentBBox","_axisProjections","radius","highlightValue","highlight","clone","entityOutOfView","hoverTrail","selectedData","target","skipCrownInnerFill","clonedSelectedData","OPACITY_HIGHLT_DIM","opacityHighlightDim","OPACITY_SELECT","opacityRegular","OPACITY_REGULAR","OPACITY_SELECT_DIM","opacitySelectDim","isHighlighted","PanZoom","Class","drag","zoom","subject","dragSubject","go","stop","filter","zoomFilter","scaleExtent","Infinity","ratioX","ratioY","sourceEvent","touches","targetTouches","mouse","self","origin","abs","e","compensateDragging","_zoomOnRectangle","_data","k","pan","isNaN","deltaY","wheelDelta","minZoomScale","zoomXOut","zoomYOut","zoomIdentity","translate","xPanOffset","yPanOffset","xRange","yRange","xRangeBumped","yRangeBumped","xRangeMinOffset","xRangeMaxOffset","yRangeMinOffset","yRangeMaxOffset","xRangeBounds","yRangeBounds","xRangeBoundsBumped","yRangeBoundsBumped","rangeBands","isDate","round","zoomedXRange","zoomedYRange","invert","set","optionsY","optionsX","transitionDuration","mmX","mmY","suggestedFrame","x1","y1","x2","y2","xBounds","yBounds","xBoundsBumped","yBoundsBumped","minX","maxX","minY","maxY","xDomain","yDomain","zoomedX1","zoomedY1","zoomedX2","zoomedY2","zoomTransform","minZoom","maxZoom","direction","ratio","log","LN2","floor","ceil","locus","pow","scaleBy","_css","_css2","Trail","_isCreated","actionsQueue","entityTrails","trailsData","trailsInProgress","activePromises","trailTransitions","delayedIterations","drawingQueue","_context","selection","Promise","resolve","reject","timePoints","getAllSteps","promises","_clearActions","status","selectedEntityData","insert","querySelector","trail","trailSegmentData","key","segment","getModelObject","trigger","all","segments","_addActions","selections","actions","promise","_getNextAction","shift","action","pop","executeSequential","response","_remove","parentNode","_resize","transparent","next","lineLength","sqrt","_recolor","strokeColor","getColorShade","colorID","shadeID","_opacityHandler","_findVisible","resolve1","reject1","getEntityLimits","cached","segmentVisibility","visibilityChanged","_groups","_abortAnimation","_reveal","delay","generateTrailSegment","nextIndex","level","datum","nextSegment","previous","nextTime","nextFrame","addNewIntervals","addPointBetween","previousIndex","previousSegment","firstLineLength","secondLineLength","mediumIndex","getPointBetween","first","_generateKeys","div","maxValue","minValue","__data__","unshift","processPoints","processPoint","pointIndex","random","point","JSON","stringify","processPointsBetween","framesAreReady","generateTrails","trailKeys","global","factory","CSS","escape","cssEscape","arguments","TypeError","codeUnit","string","String","result","firstCodeUnit","charCodeAt","charAt","g","Function","eval","window"],"mappings":"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","file":"bubblechart.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(5);\n\nvar _component = __webpack_require__(1);\n\nvar _component2 = _interopRequireDefault(_component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar VERSION_INFO = { version: \"1.0.15\", build: 1493625470905 };\n\nexports.default = Vizabi.Tool.extend(\"BubbleChart\", {\n\n  /**\n   * Initializes the tool (Bubble Chart Tool).\n   * Executed once before any template is rendered.\n   * @param {Object} placeholder Placeholder element for the tool\n   * @param {Object} external_model Model as given by the external page\n   */\n  init: function init(placeholder, external_model) {\n\n    this.name = \"bubblechart\";\n\n    //specifying components\n    this.components = [{\n      component: _component2.default,\n      placeholder: \".vzb-tool-viz\",\n      model: [\"state.time\", \"state.entities\", \"state.marker\", \"locale\", \"ui\"] //pass models to component\n    }, {\n      component: Vizabi.Component.get(\"timeslider\"),\n      placeholder: \".vzb-tool-timeslider\",\n      model: [\"state.time\", \"state.entities\", \"state.marker\", \"ui\"]\n    }, {\n      component: Vizabi.Component.get(\"dialogs\"),\n      placeholder: \".vzb-tool-dialogs\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"buttonlist\"),\n      placeholder: \".vzb-tool-buttonlist\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"treemenu\"),\n      placeholder: \".vzb-tool-treemenu\",\n      model: [\"state.marker\", \"state.marker_tags\", \"state.time\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datawarning\"),\n      placeholder: \".vzb-tool-datawarning\",\n      model: [\"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datanotes\"),\n      placeholder: \".vzb-tool-datanotes\",\n      model: [\"state.marker\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"steppedspeedslider\"),\n      placeholder: \".vzb-tool-stepped-speed-slider\",\n      model: [\"state.time\", \"locale\"]\n    }];\n\n    this._super(placeholder, external_model);\n  },\n  validate: function validate(model) {\n    model = this.model || model;\n\n    this._super(model);\n\n    if (model.ui.chart.lockNonSelected) {\n      var time = model.state.time.parse(\"\" + model.ui.chart.lockNonSelected);\n      if (time < model.state.time.start) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.start);\n      if (time > model.state.time.end) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.end);\n    }\n  },\n\n\n  /**\n   * Determines the default model of this tool\n   */\n  default_model: {\n    state: {\n      time: {\n        autogenerate: {\n          data: \"data\",\n          conceptIndex: 0,\n          conceptType: \"time\"\n        }\n      },\n      entities: {\n        autogenerate: {\n          data: \"data\",\n          conceptIndex: 0\n        }\n      },\n      entities_colorlegend: {\n        autogenerate: {\n          data: \"data\",\n          conceptIndex: 0\n        }\n      },\n      entities_tags: {},\n      marker_tags: {\n        space: [\"entities_tags\"],\n        label: {},\n        hook_parent: {}\n      },\n      marker: {\n        space: [\"entities\", \"time\"],\n        axis_x: {\n          use: \"indicator\",\n          autogenerate: {\n            conceptIndex: 1,\n            conceptType: \"measure\"\n          }\n        },\n        axis_y: {\n          use: \"indicator\",\n          autogenerate: {\n            conceptIndex: 0,\n            conceptType: \"measure\"\n          }\n        },\n        label: {\n          use: \"property\",\n          autogenerate: {\n            conceptIndex: 0\n          }\n        },\n        size: {\n          autogenerate: {\n            conceptIndex: 2,\n            conceptType: \"measure\"\n          }\n        },\n        color: {\n          syncModels: [\"marker_colorlegend\"],\n          autogenerate: {\n            conceptIndex: 0,\n            conceptType: \"entity_set\"\n          }\n        },\n        size_label: {\n          use: \"constant\",\n          which: \"_default\",\n          scaleType: \"ordinal\",\n          _important: false,\n          extent: [0, 0.33],\n          allow: {\n            names: [\"_default\"]\n          }\n        }\n      },\n      \"marker_colorlegend\": {\n        \"space\": [\"entities_colorlegend\"],\n        \"label\": {\n          \"use\": \"property\",\n          \"which\": \"name\"\n        },\n        \"hook_rank\": {\n          \"use\": \"property\",\n          \"which\": \"rank\"\n        },\n        \"hook_geoshape\": {\n          \"use\": \"property\",\n          \"which\": \"shape_lores_svg\"\n        }\n      }\n    },\n    locale: {},\n    ui: {\n      chart: {\n        whenHovering: {\n          showProjectionLineX: true,\n          showProjectionLineY: true,\n          higlightValueX: true,\n          higlightValueY: true\n        },\n        labels: {\n          dragging: true,\n          removeLabelBox: false\n        },\n        trails: true,\n        lockNonSelected: 0\n      },\n      datawarning: {\n        doubtDomain: [],\n        doubtRange: []\n      },\n      presentation: false,\n      panWithArrow: false,\n      adaptMinMaxZoom: false,\n      cursorMode: \"arrow\",\n      zoomOnScrolling: false,\n      buttons: [\"colors\", \"find\", \"trails\", \"lock\", \"moreoptions\", \"fullscreen\", \"presentation\"],\n      dialogs: {\n        popup: [\"colors\", \"find\", \"size\", \"zoom\", \"moreoptions\"],\n        sidebar: [\"colors\", \"find\", \"size\", \"zoom\"],\n        moreoptions: [\"opacity\", \"speed\", \"axes\", \"size\", \"colors\", \"label\", \"zoom\", \"presentation\", \"about\"]\n      }\n    }\n  },\n\n  versionInfo: VERSION_INFO\n});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trail = __webpack_require__(3);\n\nvar _trail2 = _interopRequireDefault(_trail);\n\nvar _panzoom = __webpack_require__(2);\n\nvar _panzoom2 = _interopRequireDefault(_panzoom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _Vizabi = Vizabi,\n    utils = _Vizabi.utils;\nvar _Vizabi$helpers = Vizabi.helpers,\n    Exporter = _Vizabi$helpers.svgexport,\n    Labels = _Vizabi$helpers.labels,\n    axisSmart = _Vizabi$helpers['d3.axisWithLabelPicker'],\n    DynamicBackground = _Vizabi$helpers['d3.dynamicBackground'];\nvar _Vizabi$iconset = Vizabi.iconset,\n    iconWarn = _Vizabi$iconset.warn,\n    iconQuestion = _Vizabi$iconset.question;\n\n\n// BUBBLE CHART COMPONENT\nvar BubbleChart = Vizabi.Component.extend(\"bubblechart\", {\n\n  /**\n   * Initializes the component (Bubble Chart).\n   * Executed once before any template is rendered.\n   * @param {Object} config The config passed to the component\n   * @param {Object} context The component's parent\n   */\n  init: function init(config, context) {\n    var _this = this;\n    this.name = \"bubblechart\";\n    this.template = __webpack_require__(6);\n\n    //define expected models for this component\n    this.model_expects = [{\n      name: \"time\",\n      type: \"time\"\n    }, {\n      name: \"entities\",\n      type: \"entities\"\n    }, {\n      name: \"marker\",\n      type: \"model\"\n    }, {\n      name: \"locale\",\n      type: \"locale\"\n    }, {\n      name: \"ui\",\n      type: \"ui\"\n    }];\n\n    this.model_binds = {\n      \"change:time.playing\": function changeTimePlaying(evt, original) {\n        if (utils.isTouchDevice() && _this.model.time.playing && _this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n      },\n      \"change:time.start\": function changeTimeStart(evt, original) {\n        if (_this.model.marker.color.scaleType === \"time\") {\n          _this.model.marker.color.scale = null;\n        }\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        _this._trails.create().then(function () {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.end\": function changeTimeEnd(evt, original) {\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        _this._trails.create().then(function () {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.record\": function changeTimeRecord() {\n        //console.log(\"change time record\");\n        if (_this.model.time.record) {\n          _this._export.open(this.element, this.name);\n        } else {\n          _this._export.reset();\n        }\n      },\n      \"change:ui.chart.trails\": function changeUiChartTrails(evt) {\n        //console.log(\"EVENT change:time:trails\");\n        _this._trails.toggle(_this.model.ui.chart.trails);\n        _this.redrawDataPoints();\n      },\n      \"change:ui.chart.lockNonSelected\": function changeUiChartLockNonSelected(evt) {\n        //console.log(\"EVENT change:time:lockNonSelected\");\n        _this.redrawDataPoints(500);\n      },\n      \"change:marker\": function changeMarker(evt, path) {\n        // bubble size change is processed separately\n        if (!_this._readyOnce) return;\n        if (path.indexOf(\"scaleType\") > -1) {\n          _this.ready();\n          return;\n        }\n\n        if (path.indexOf(\"marker.color\") !== -1) return;\n        if (path.indexOf(\"marker.size\") !== -1) return;\n        if (path.indexOf(\"marker.size_label\") !== -1) return;\n\n        if (path.indexOf(\"domainMin\") > -1 || path.indexOf(\"domainMax\") > -1) {\n          if (!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress\n          _this.updateSize();\n          _this.updateMarkerSizeLimits();\n          _this._trails.run(\"findVisible\");\n          _this.redrawDataPoints();\n          _this._trails.run(\"resize\", null, 500);\n        } else if (path.indexOf(\"zoomedMin\") > -1 || path.indexOf(\"zoomedMax\") > -1) {\n          if (_this.draggingNow) return;\n\n          //avoid zooming again if values didn't change.\n          //also prevents infinite loop on forced URL update from zoom.stop()\n          if (utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMin, _this.model.marker.axis_x.zoomedMin, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMax, _this.model.marker.axis_x.zoomedMax, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMin, _this.model.marker.axis_y.zoomedMin, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMax, _this.model.marker.axis_y.zoomedMax, 0.01)) return;\n          var playAfterZoom = false;\n          if (_this.model.time.playing) {\n            playAfterZoom = true;\n            _this.model.time.pause(true);\n          }\n          _this._trails.run(\"abortAnimation\");\n          _this._panZoom.zoomToMaxMin(_this.model.marker.axis_x.getZoomedMin(), _this.model.marker.axis_x.getZoomedMax(), _this.model.marker.axis_y.getZoomedMin(), _this.model.marker.axis_y.getZoomedMax(), 500 /*duration*/, \"don't feed these zoom values back to state\");\n          if (playAfterZoom) {\n            _this.model.time.postponePause = false;\n          }\n        }\n\n        //console.log(\"EVENT change:marker\", evt);\n      },\n      \"change:marker.select\": function changeMarkerSelect(evt, path) {\n        if (!_this._readyOnce || !_this.entityBubbles) return;\n        //console.log(\"EVENT change:entities:select\");\n\n        //disable trails if too many items get selected at once\n        //otherwise it's too much waiting time\n        if ((evt.source._val || []).length - (evt.source._previousVal || []).length > 50) _this.model.ui.chart.trails = false;\n\n        _this.selectDataPoints();\n        _this.redrawDataPoints();\n        _this._trails.create().then(function () {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n        _this.updateBubbleOpacity();\n        _this._updateDoubtOpacity();\n      },\n      \"change:marker.highlight\": function changeMarkerHighlight(evt, path) {\n        if (!_this._readyOnce) return;\n        //path have values if trail is highlighted\n        if (path != \"highlight\") {\n          if (path !== null) {\n            var titles = _this._formatSTitleValues(path.size, path.color);\n            _this._updateSTitle(titles[0], titles[1]);\n          } else {\n            _this._updateSTitle();\n          }\n          return;\n        }\n        //console.log(\"EVENT change:entities:highlight\");\n        _this.highlightDataPoints();\n      },\n      \"change:time.value\": function changeTimeValue() {\n        if (!_this._readyOnce || !_this.entityBubbles) return;\n        if (!_this.calculationQueue) {\n          // collect timestamp that we request\n          _this.calculationQueue = [_this.model.time.value.toString()];\n        } else {\n          _this.calculationQueue.push(_this.model.time.value.toString());\n        }\n        (function (time) {\n          // isolate timestamp\n          //_this._bubblesInteract().mouseout();\n          _this.model.marker.getFrame(time, function (frame, time) {\n            if (!_this._frameIsValid(frame)) return utils.warn(\"change:time.value: empty data received from marker.getFrame(). doing nothing\");\n            var index = _this.calculationQueue.indexOf(time.toString()); //\n            if (index == -1) {\n              // we was receive more recent frame before so we pass this frame\n              return;\n            }\n            _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp\n            _this.frameChanged(frame, time);\n          });\n        })(_this.model.time.value);\n      },\n      \"change:ui.adaptMinMaxZoom\": function changeUiAdaptMinMaxZoom() {\n        //console.log(\"EVENT change:ui:adaptMinMaxZoom\");\n        if (_this.model.ui.adaptMinMaxZoom) {\n          _this._panZoom.expandCanvas(500);\n        } else {\n          _this._panZoom.reset();\n        }\n      },\n      \"change:marker.size.extent\": function changeMarkerSizeExtent(evt, path) {\n        //console.log(\"EVENT change:marker:size:max\");\n        if (!_this._readyOnce) return;\n        _this.updateMarkerSizeLimits();\n        _this.redrawDataPointsOnlySize();\n        _this._trails.run(\"resize\");\n      },\n      \"change:marker.color\": function changeMarkerColor(evt, path) {\n        if (!_this._readyOnce) return;\n        //console.log(\"EVENT change:marker:color:palette\");\n        _this.redrawDataPointsOnlyColors();\n        _this._trails.run(\"recolor\");\n      },\n      // 'change:marker.color.palette': function(evt, path) {\n      //   if(!_this._readyOnce) return;\n      //   //console.log(\"EVENT change:marker:color:palette\");\n      //   _this.redrawDataPointsOnlyColors();\n      //   _this._trails.run(\"recolor\");\n      // },\n      \"change:marker.opacitySelectDim\": function changeMarkerOpacitySelectDim() {\n        _this.updateBubbleOpacity();\n      },\n      \"change:marker.opacityRegular\": function changeMarkerOpacityRegular() {\n        _this.updateBubbleOpacity();\n        _this._trails.run(\"opacityHandler\");\n      },\n      \"change:ui.cursorMode\": function changeUiCursorMode() {\n        var svg = _this.chartSvg;\n        if (_this.model.ui.cursorMode === \"plus\") {\n          svg.classed(\"vzb-zoomin\", true);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"minus\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", true);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"hand\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", true);\n        } else {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        }\n      },\n      \"change:entities.dim\": function changeEntitiesDim() {\n        if (_this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n        if (_this.someSelected) {\n          _this.model.marker.clearSelected();\n        }\n      },\n      \"ready\": function ready() {\n        // if(_this.model.marker.color.scaleType === 'time') {\n        //   _this.model.marker.color.scale = null;\n        //   utils.defer(function() {\n        //     _this.trigger('ready');\n        //   });\n        // }\n      }\n    };\n\n    this._super(config, context);\n\n    this.xScale = null;\n    this.yScale = null;\n    this.sScale = null;\n    this.cScale = null;\n\n    this.xAxis = axisSmart(\"bottom\");\n    this.yAxis = axisSmart(\"left\");\n\n    _this.COLOR_BLACKISH = \"#333\";\n    _this.COLOR_WHITEISH = \"#fdfdfd\";\n\n    this.isCanvasPreviouslyExpanded = false;\n    this.draggingNow = null;\n\n    this._trails = new _trail2.default(this);\n    this._panZoom = new _panzoom2.default(this);\n    this._export = new Exporter(this);\n    this._export.prefix(\"vzb-bc-\").deleteClasses([\"vzb-bc-bubbles-crop\", \"vzb-hidden\", \"vzb-bc-year\", \"vzb-bc-zoom-rect\", \"vzb-bc-projection-x\", \"vzb-bc-projection-y\", \"vzb-bc-axis-c-title\"]);\n    this._labels = new Labels(this);\n    this._labels.config({\n      CSS_PREFIX: \"vzb-bc\",\n      LABELS_CONTAINER_CLASS: \"vzb-bc-labels\",\n      LINES_CONTAINER_CLASS: \"vzb-bc-bubbles\",\n      LINES_CONTAINER_SELECTOR_PREFIX: \"bubble-\"\n    });\n  },\n  _rangeBump: function _rangeBump(arg, undo) {\n    var bump = this.activeProfile.maxRadiusPx / 2;\n    undo = undo ? -1 : 1;\n    if (utils.isArray(arg) && arg.length > 1) {\n      var z1 = arg[0];\n      var z2 = arg[arg.length - 1];\n\n      //the sign of bump depends on the direction of the scale\n      if (z1 < z2) {\n        z1 += bump * undo;\n        z2 -= bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 > z2) z1 = z2 = (z1 + z2) / 2;\n      } else if (z1 > z2) {\n        z1 -= bump * undo;\n        z2 += bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 < z2) z1 = z2 = (z1 + z2) / 2;\n      } else {\n        // rangeBump error: the input scale range has 0 length. that sucks but we keep cool\n      }\n      return [z1, z2];\n    }\n    utils.warn(\"rangeBump error: input is not an array or empty\");\n  },\n\n\n  /**\n   * Executes right after the template is in place, but the model is not yet ready\n   */\n  readyOnce: function readyOnce() {\n    var _this = this;\n    this._readyOnce = false;\n    this.scrollableAncestor = utils.findScrollableAncestor(this.element);\n    this.element = d3.select(this.element);\n\n    // reference elements\n    this.chartSvg = this.element.select(\"svg\");\n    this.graph = this.element.select(\".vzb-bc-graph\");\n    this.yAxisElContainer = this.graph.select(\".vzb-bc-axis-y\");\n    this.yAxisEl = this.yAxisElContainer.select(\"g\");\n\n    this.xAxisElContainer = this.graph.select(\".vzb-bc-axis-x\");\n    this.xAxisEl = this.xAxisElContainer.select(\"g\");\n\n    this.yTitleEl = this.graph.select(\".vzb-bc-axis-y-title\");\n    this.xTitleEl = this.graph.select(\".vzb-bc-axis-x-title\");\n    this.sTitleEl = this.graph.select(\".vzb-bc-axis-s-title\");\n    this.cTitleEl = this.graph.select(\".vzb-bc-axis-c-title\");\n    this.yearEl = this.graph.select(\".vzb-bc-year\");\n\n    this.year = new DynamicBackground(this.yearEl);\n\n    this.yInfoEl = this.graph.select(\".vzb-bc-axis-y-info\");\n    this.xInfoEl = this.graph.select(\".vzb-bc-axis-x-info\");\n    this.dataWarningEl = this.graph.select(\".vzb-data-warning\");\n\n    this.projectionX = this.graph.select(\".vzb-bc-projection-x\");\n    this.projectionY = this.graph.select(\".vzb-bc-projection-y\");\n    this.lineEqualXY = this.graph.select(\".vzb-bc-line-equal-xy\");\n\n    this.trailsContainer = this.graph.select(\".vzb-bc-trails\");\n    this.bubbleContainerCrop = this.graph.select(\".vzb-bc-bubbles-crop\");\n    this.zoomSelection = this.graph.select(\".vzb-zoom-selection\");\n    this.labelsContainerCrop = this.graph.select(\".vzb-bc-labels-crop\");\n    this.bubbleContainer = this.graph.select(\".vzb-bc-bubbles\");\n    this.labelsContainer = this.graph.select(\".vzb-bc-labels\");\n    this.linesContainer = this.graph.select(\".vzb-bc-lines\");\n    this.zoomRect = this.element.select(\".vzb-bc-zoom-rect\");\n    this.eventArea = this.element.select(\".vzb-bc-eventarea\");\n\n    this.entityBubbles = null;\n    this.bubbleCrown = this.element.select(\".vzb-bc-bubble-crown\");\n    //set filter\n    this.bubbleCrown.selectAll(\".vzb-crown-glow\").attr(\"filter\", \"url(\" + location.pathname + \"#vzb-glow-filter)\");\n    this.tooltip = this.element.select(\".vzb-bc-tooltip\");\n    //set filter\n    this.tooltip.select(\".vzb-tooltip-glow\").attr(\"filter\", \"url(\" + location.pathname + \"#vzb-glow-filter)\");\n\n    this.tooltipMobile = this.element.select(\".vzb-tooltip-mobile\");\n    //component events\n    this.on(\"resize\", function () {\n      //console.log(\"EVENT: resize\");\n      //return if updatesize exists with error\n      _this._trails.run(\"abortAnimation\");\n      if (_this.updateSize()) return;\n      _this.updateMarkerSizeLimits();\n      _this._labels.updateSize();\n      (function (xMin, xMax, yMin, yMax) {\n        _this._panZoom.zoomer.dontFeedToState = true;\n        _this._panZoom.rerun(); // includes redraw data points and trail resize\n        _this._panZoom.zoomToMaxMin(xMin, xMax, yMin, yMax, 0, true);\n      })(_this._zoomedXYMinMax.axis_x.zoomedMin, _this._zoomedXYMinMax.axis_x.zoomedMax, _this._zoomedXYMinMax.axis_y.zoomedMin, _this._zoomedXYMinMax.axis_y.zoomedMax);\n    });\n\n    //keyboard listeners\n    d3.select(\"body\").on(\"keydown\", function () {\n      if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      if (d3.event.metaKey || d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", true);\n    }).on(\"keyup\", function () {\n      if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n    })\n    //this is for the case when user would press ctrl and move away from the browser tab or window\n    //keyup event would happen somewhere else and won't be captured, so zoomin class would get stuck\n    .on(\"mouseenter\", function () {\n      if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n    });\n\n    this.root.on(\"resetZoom\", function () {\n      _this._panZoom.reset(null, 500);\n    });\n\n    this._panZoom.zoomSelection(this.bubbleContainerCrop);\n    this.bubbleContainerCrop.call(this._panZoom.dragRectangle).call(this._panZoom.zoomer).on(\"dblclick.zoom\", null).on(\"mouseup\", function () {\n      _this.draggingNow = false;\n    }).on(\"click\", function () {\n      var cursor = _this.model.ui.cursorMode;\n      if (!d3.event.defaultPrevented && cursor !== \"arrow\" && cursor !== \"hand\") {\n        _this._panZoom.zoomByIncrement(cursor, 500);\n      }\n    });\n\n    this.KEY = this.model.entities.getDimension();\n    this.TIMEDIM = this.model.time.getDimension();\n\n    this.updateUIStrings();\n\n    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);\n\n    this._labels.readyOnce();\n\n    _this._readyOnce = true;\n  },\n  _frameIsValid: function _frameIsValid(frame) {\n    return !(!frame || Object.keys(frame.axis_y).length === 0 || Object.keys(frame.axis_x).length === 0 || Object.keys(frame.size).length === 0);\n  },\n  ready: function ready() {\n    var _this = this;\n    this.KEY = this.model.entities.getDimension();\n    this.updateUIStrings();\n    var endTime = this.model.time.end;\n    this.updateIndicators();\n    this.updateTime();\n    if (!_this.model.time.splash) {\n      _this._trails.create();\n    }\n    this.model.marker.getFrame(this.model.time.value, function (frame, time) {\n      // TODO: temporary fix for case when after data loading time changed on validation\n      if (time.toString() != _this.model.time.value.toString()) {\n        utils.defer(function () {\n          _this.ready();\n        });\n        return;\n      }\n      if (!_this._frameIsValid(frame)) return utils.warn(\"ready: empty data received from marker.getFrame(). doing nothing\");\n\n      _this.frame = frame;\n      _this.updateSize();\n      _this.updateMarkerSizeLimits();\n      _this.updateEntities();\n      _this._labels.ready();\n      _this.redrawDataPoints();\n      _this.selectDataPoints();\n      _this.updateBubbleOpacity();\n      _this._updateDoubtOpacity();\n      _this.zoomToMarkerMaxMin(); // includes redraw data points and trail resize\n      if (!_this.model.time.splash) {\n        _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      }\n      if (_this.model.ui.adaptMinMaxZoom) _this._panZoom.expandCanvas();\n    });\n  },\n\n\n  /*\n   * Zoom to the min and max values given in the URL axes markers.\n   */\n  zoomToMarkerMaxMin: function zoomToMarkerMaxMin() {\n    /*\n     * Reset just the zoom values without triggering a zoom event. This ensures\n     * a clean zoom state for the subsequent zoom event.\n     */\n    this._panZoom.resetZoomState();\n\n    var xAxis = this.model.marker.axis_x;\n    var yAxis = this.model.marker.axis_y;\n\n    var xDomain = xAxis.getScale().domain();\n    var yDomain = yAxis.getScale().domain();\n\n    /*\n     * The axes may return null when there is no value given for the zoomed\n     * min and max values. In that case, fall back to the axes' domain values.\n     */\n    var zoomedMinX = xAxis.getZoomedMin();\n    var zoomedMaxX = xAxis.getZoomedMax();\n    var zoomedMinY = yAxis.getZoomedMin();\n    var zoomedMaxY = yAxis.getZoomedMax();\n\n    //by default this will apply no transition and feed values back to state\n    this._panZoom.zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, 0, \"don't feed these zoom values back to state\");\n  },\n\n\n  /*\n   * UPDATE INDICATORS\n   */\n  updateIndicators: function updateIndicators() {\n    var _this = this;\n\n    //scales\n    this.yScale = this.model.marker.axis_y.getScale();\n    this.xScale = this.model.marker.axis_x.getScale();\n    this.sScale = this.model.marker.size.getScale();\n    this.cScale = this.model.marker.color.getScale();\n    this._labels.setScales(this.xScale, this.yScale);\n\n    this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());\n    this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());\n  },\n  frameChanged: function frameChanged(frame, time) {\n    //    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated\n    this.frame = frame;\n    this.updateTime();\n\n    this._updateDoubtOpacity();\n    this._trails.run(\"findVisible\");\n    if (this.model.ui.adaptMinMaxZoom) {\n      this._panZoom.expandCanvas();\n    } else {\n      this.redrawDataPoints();\n    }\n    this._trails.run(\"reveal\", null, this.duration);\n    this.tooltipMobile.classed(\"vzb-hidden\", true);\n    this._reorderEntities();\n  },\n  updateUIStrings: function updateUIStrings() {\n    var _this = this;\n\n    var conceptPropsY = _this.model.marker.axis_y.getConceptprops();\n    var conceptPropsX = _this.model.marker.axis_x.getConceptprops();\n    var conceptPropsS = _this.model.marker.size.getConceptprops();\n    var conceptPropsC = _this.model.marker.color.getConceptprops();\n    this.translator = this.model.locale.getTFunction();\n\n    this.strings = {\n      title: {\n        Y: conceptPropsY.name,\n        X: conceptPropsX.name,\n        S: conceptPropsS.name,\n        C: conceptPropsC.name\n      },\n      unit: {\n        Y: conceptPropsY.unit || \"\",\n        X: conceptPropsX.unit || \"\",\n        S: conceptPropsS.unit || \"\",\n        C: conceptPropsC.unit || \"\"\n      }\n    };\n\n    var yTitle = this.yTitleEl.selectAll(\"text\").data([0]);\n    yTitle.enter().append(\"text\");\n    yTitle\n    //.attr(\"y\", \"-6px\")\n    .on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-treemenu\").markerID(\"axis_y\").alignX(_this.model.locale.isRTL() ? \"right\" : \"left\").alignY(\"top\").updateView().toggle();\n    });\n\n    var xTitle = this.xTitleEl.selectAll(\"text\").data([0]);\n    xTitle.enter().append(\"text\");\n    xTitle.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-treemenu\").markerID(\"axis_x\").alignX(_this.model.locale.isRTL() ? \"right\" : \"left\").alignY(\"bottom\").updateView().toggle();\n    });\n\n    var sTitle = this.sTitleEl.selectAll(\"text\").data([0]);\n    sTitle.enter().append(\"text\");\n    sTitle.attr(\"text-anchor\", \"end\");\n\n    utils.setIcon(this.dataWarningEl, iconWarn).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n    this.dataWarningEl.append(\"text\").attr(\"text-anchor\", \"end\").text(this.translator(\"hints/dataWarning\"));\n\n    utils.setIcon(this.yInfoEl, iconQuestion).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n\n    utils.setIcon(this.xInfoEl, iconQuestion).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n\n    //TODO: move away from UI strings, maybe to ready or ready once\n    this.yInfoEl.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.yInfoEl.on(\"mouseover\", function () {\n      var rect = this.getBBox();\n      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      var toolRect = _this.root.element.getBoundingClientRect();\n      var chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_y\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.yInfoEl.on(\"mouseout\", function () {\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.xInfoEl.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.xInfoEl.on(\"mouseover\", function () {\n      if (_this.model.time.dragging) return;\n      var rect = this.getBBox();\n      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      var toolRect = _this.root.element.getBoundingClientRect();\n      var chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_x\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.xInfoEl.on(\"mouseout\", function () {\n      if (_this.model.time.dragging) return;\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.dataWarningEl.on(\"click\", function () {\n      _this.parent.findChildByName(\"gapminder-datawarning\").toggle();\n    }).on(\"mouseover\", function () {\n      _this._updateDoubtOpacity(1);\n    }).on(\"mouseout\", function () {\n      _this._updateDoubtOpacity();\n    });\n  },\n  _updateDoubtOpacity: function _updateDoubtOpacity(opacity) {\n    if (opacity == null) opacity = this.wScale(+this.model.time.formatDate(this.time));\n    if (this.someSelected) opacity = 1;\n    this.dataWarningEl.style(\"opacity\", opacity);\n  },\n\n\n  /*\n   * UPDATE ENTITIES:\n   * Ideally should only update when show parameters change or data changes\n   */\n  updateEntities: function updateEntities() {\n    var _this = this;\n    var KEY = this.KEY;\n    var TIMEDIM = this.TIMEDIM;\n\n    var getKeys = function getKeys(prefix) {\n      prefix = prefix || \"\";\n      return _this.model.marker.getKeys().map(function (d) {\n        var pointer = {};\n        pointer[KEY] = d[KEY];\n        pointer[TIMEDIM] = endTime;\n        pointer.sortValue = _this.frame.size[d[KEY]] || 0;\n        pointer[KEY] = prefix + d[KEY];\n        return pointer;\n      }).sort(function (a, b) {\n        return b.sortValue - a.sortValue;\n      });\n    };\n\n    // get array of GEOs, sorted by the size hook\n    // that makes larger bubbles go behind the smaller ones\n    var endTime = this.model.time.end;\n    var markers = getKeys.call(this);\n    this.model.marker.setVisible(markers);\n\n    //unselecting bubbles with no data is used for the scenario when\n    //some bubbles are selected and user would switch indicator.\n    //bubbles would disappear but selection would stay\n    if (!this.model.time.splash) {\n      this.unselectBubblesWithNoData(markers);\n    }\n    this.entityBubbles = this.bubbleContainer.selectAll(\"circle.vzb-bc-entity\").data(this.model.marker.getVisible(), function (d) {\n      return d[KEY];\n    }); // trails have not keys\n\n    //exit selection\n    this.entityBubbles.exit().remove();\n\n    //enter selection -- init circles\n    this.entityBubbles = this.entityBubbles.enter().append(\"circle\").attr(\"class\", function (d) {\n      return \"vzb-bc-entity \" + \"bubble-\" + d[KEY];\n    }).on(\"mouseover\", function (d, i) {\n      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n      _this._bubblesInteract().mouseover(d, i);\n    }).on(\"mouseout\", function (d, i) {\n      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n\n      _this._bubblesInteract().mouseout(d, i);\n    }).on(\"click\", function (d, i) {\n      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n\n      _this._bubblesInteract().click(d, i);\n    }).onTap(function (d, i) {\n      d3.event.stopPropagation();\n      _this._bubblesInteract().click(d, i);\n    }).onLongTap(function (d, i) {}).merge(this.entityBubbles);\n\n    this._reorderEntities();\n  },\n  unselectBubblesWithNoData: function unselectBubblesWithNoData(entities) {\n    var _this = this;\n    var KEY = this.KEY;\n    if (!this.model.marker.select.length) return;\n\n    var _select = [];\n    var keys = entities.map(function (d) {\n      return d[KEY];\n    });\n\n    this.model.marker.select.forEach(function (d) {\n      if (keys.indexOf(d[KEY]) !== -1) _select.push(d);\n    });\n\n    if (_select.length !== _this.model.marker.select.length) _this.model.marker.select = _select;\n  },\n  _reorderEntities: function _reorderEntities() {\n    var _this = this;\n    var KEY = this.KEY;\n    this.bubbleContainer.selectAll(\".vzb-bc-entity\").sort(function (a, b) {\n      var sizeA = _this.frame.size[a[KEY]];\n      var sizeB = _this.frame.size[b[KEY]];\n\n      if (typeof sizeA === \"undefined\" && typeof sizeB !== \"undefined\") return -1;\n      if (typeof sizeA !== \"undefined\" && typeof sizeB === \"undefined\") return 1;\n      if (sizeA != sizeB) return d3.descending(sizeA, sizeB);\n      if (a[KEY] != b[KEY]) return d3.ascending(a[KEY], b[KEY]);\n      if (typeof a.trailStartTime !== \"undefined\" || typeof b.trailStartTime !== \"undefined\") return typeof a.trailStartTime !== \"undefined\" ? -1 : 1; // only lines has trailStartTime\n      if (typeof a.limits !== \"undefined\" || typeof b.limits !== \"undefined\") return typeof a.limits !== \"undefined\" ? -1 : 1; // only trails has attribute limits\n      return d3.descending(sizeA, sizeB);\n    });\n  },\n  _bubblesInteract: function _bubblesInteract() {\n    var _this = this;\n    var KEY = this.KEY;\n    var TIMEDIM = this.TIMEDIM;\n\n    return {\n      mouseover: function mouseover(d, i) {\n        _this.model.marker.highlightMarker(d);\n\n        _this._labels.showCloseCross(d, true);\n      },\n      mouseout: function mouseout(d, i) {\n        _this.model.marker.clearHighlighted();\n\n        _this._labels.showCloseCross(d, false);\n      },\n      click: function click(d, i) {\n        if (_this.draggingNow) return;\n        var isSelected = _this.model.marker.isSelected(d);\n        _this.model.marker.selectMarker(d);\n        //return to highlighted state\n        if (!utils.isTouchDevice()) {\n          if (isSelected) _this.model.marker.highlightMarker(d);\n          _this.highlightDataPoints();\n        }\n      }\n    };\n  },\n\n\n  /*\n   * UPDATE TIME:\n   * Ideally should only update when time or data changes\n   */\n  updateTime: function updateTime() {\n    var _this = this;\n\n    this.time_1 = this.time == null ? this.model.time.value : this.time;\n    this.time = this.model.time.value;\n    this.duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;\n    this.year.setText(this.model.time.formatDate(this.time, \"ui\"), this.duration);\n  },\n\n\n  /*\n   * RESIZE:\n   * Executed whenever the container is resized\n   */\n  updateSize: function updateSize() {\n\n    var profiles = {\n      small: {\n        margin: { top: 30, right: 10, left: 40, bottom: 35 },\n        padding: 2,\n        minRadiusPx: 0.5,\n        maxRadiusEm: 0.05,\n        infoElHeight: 16,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 4\n      },\n      medium: {\n        margin: { top: 40, right: 15, left: 60, bottom: 55 },\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: 0.05,\n        infoElHeight: 20,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 5\n      },\n      large: {\n        margin: { top: 50, right: 20, left: 60, bottom: 60 },\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: 0.05,\n        infoElHeight: 22,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 5,\n        hideSTitle: true\n      }\n    };\n\n    var presentationProfileChanges = {\n      \"medium\": {\n        margin: { top: 80, bottom: 80, left: 100 },\n        yAxisTitleBottomMargin: 20,\n        xAxisTitleBottomMargin: 20,\n        infoElHeight: 26\n      },\n      \"large\": {\n        margin: { top: 80, bottom: 100, left: 100 },\n        yAxisTitleBottomMargin: 20,\n        xAxisTitleBottomMargin: 20,\n        infoElHeight: 32,\n        hideSTitle: true\n      }\n    };\n\n    var _this = this;\n\n    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);\n\n    var containerWH = this.root.getVizWidthHeight();\n    this.activeProfile.maxRadiusPx = Math.max(this.activeProfile.minRadiusPx, this.activeProfile.maxRadiusEm * utils.hypotenuse(containerWH.width, containerWH.height));\n\n    var margin = this.activeProfile.margin;\n    var infoElHeight = this.activeProfile.infoElHeight;\n\n    //labels\n    _this._labels.setCloseCrossHeight(_this.activeProfile.infoElHeight * 1.2);\n\n    //stage\n    this.height = parseInt(this.element.style(\"height\"), 10) - margin.top - margin.bottom || 0;\n    this.width = parseInt(this.element.style(\"width\"), 10) - margin.left - margin.right || 0;\n\n    if (this.height <= 0 || this.width <= 0) {\n      this.height = 0;\n      this.width = 0;\n      utils.warn(\"Bubble chart updateSize(): vizabi container is too little or has display:none\");\n    }\n\n    //graph group is shifted according to margins (while svg element is at 100 by 100%)\n    this.graph.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    this.year.resize(this.width, this.height);\n    this.eventArea.attr(\"width\", this.width).attr(\"height\", Math.max(0, this.height));\n\n    //update scales to the new range\n    if (this.model.marker.axis_y.scaleType !== \"ordinal\") {\n      this.yScale.range(this._rangeBump([this.height, 0]));\n    } else {\n      this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();\n    }\n    if (this.model.marker.axis_x.scaleType !== \"ordinal\") {\n      this.xScale.range(this._rangeBump([0, this.width]));\n    } else {\n      this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();\n    }\n\n    //apply scales to axes and redraw\n    this.yAxis.scale(this.yScale).tickSizeInner(-this.width).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.width, 0).labelerOptions({\n      scaleType: this.model.marker.axis_y.scaleType,\n      toolMargin: margin,\n      limitMaxTickNumber: 6,\n      bump: this.activeProfile.maxRadiusPx / 2,\n      viewportLength: this.height,\n      formatter: this.model.marker.axis_y.getTickFormatter()\n    });\n\n    this.xAxis.scale(this.xScale).tickSizeInner(-this.height).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.height, 0).labelerOptions({\n      scaleType: this.model.marker.axis_x.scaleType,\n      toolMargin: margin,\n      bump: this.activeProfile.maxRadiusPx / 2,\n      viewportLength: this.width,\n      formatter: this.model.marker.axis_x.getTickFormatter()\n    });\n\n    this.bubbleContainerCrop.attr(\"width\", this.width).attr(\"height\", Math.max(0, this.height));\n\n    this.labelsContainerCrop.attr(\"width\", this.width).attr(\"height\", Math.max(0, this.height));\n\n    this.xAxisElContainer.attr(\"width\", this.width + 1).attr(\"height\", this.activeProfile.margin.bottom + this.height).attr(\"y\", -1).attr(\"x\", -1);\n    this.xAxisEl.attr(\"transform\", \"translate(1,\" + (1 + this.height) + \")\");\n\n    this.yAxisElContainer.attr(\"width\", this.activeProfile.margin.left + this.width).attr(\"height\", Math.max(0, this.height)).attr(\"x\", -this.activeProfile.margin.left);\n    this.yAxisEl.attr(\"transform\", \"translate(\" + (this.activeProfile.margin.left - 1) + \",\" + 0 + \")\");\n\n    this.yAxisEl.call(this.yAxis);\n    this.xAxisEl.call(this.xAxis);\n\n    this.projectionX.attr(\"y1\", _this.yScale.range()[0] + this.activeProfile.maxRadiusPx / 2);\n    this.projectionY.attr(\"x2\", _this.xScale.range()[0] - this.activeProfile.maxRadiusPx / 2);\n\n    // reduce font size if the caption doesn't fit\n    this._updateSTitle();\n    this.sTitleEl.attr(\"transform\", \"translate(\" + this.width + \",\" + 20 + \") rotate(-90)\");\n\n    var isRTL = this.model.locale.isRTL();\n    this.yTitleEl.style(\"font-size\", infoElHeight + \"px\").attr(\"transform\", \"translate(\" + (isRTL ? this.width : 10 - this.activeProfile.margin.left) + \", -\" + this.activeProfile.yAxisTitleBottomMargin + \")\");\n\n    this.xTitleEl.style(\"font-size\", infoElHeight + \"px\").attr(\"transform\", \"translate(\" + (isRTL ? this.width : 0) + \",\" + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\");\n\n    var ySeparator = this.strings.unit.Y ? \", \" : \"\";\n    var yTitleText = this.yTitleEl.select(\"text\").text(this.strings.title.Y + ySeparator + this.strings.unit.Y);\n    if (yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title.Y);\n\n    var xSeparator = this.strings.unit.Y ? \", \" : \"\";\n    var xTitleText = this.xTitleEl.select(\"text\").text(this.strings.title.X + xSeparator + this.strings.unit.X);\n    if (xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title.X);\n\n    if (this.yInfoEl.select(\"svg\").node()) {\n      var titleBBox = this.yTitleEl.node().getBBox();\n      var t = utils.transform(this.yTitleEl.node());\n      var hTranslate = isRTL ? titleBBox.x + t.translateX - infoElHeight * 1.4 : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4;\n\n      this.yInfoEl.select(\"svg\").attr(\"width\", infoElHeight + \"px\").attr(\"height\", infoElHeight + \"px\");\n      this.yInfoEl.attr(\"transform\", \"translate(\" + hTranslate + \",\" + (t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    if (this.xInfoEl.select(\"svg\").node()) {\n      var _titleBBox = this.xTitleEl.node().getBBox();\n      var _t = utils.transform(this.xTitleEl.node());\n      var _hTranslate = isRTL ? _titleBBox.x + _t.translateX - infoElHeight * 1.4 : _titleBBox.x + _t.translateX + _titleBBox.width + infoElHeight * 0.4;\n\n      this.xInfoEl.select(\"svg\").attr(\"width\", infoElHeight + \"px\").attr(\"height\", infoElHeight + \"px\");\n      this.xInfoEl.attr(\"transform\", \"translate(\" + _hTranslate + \",\" + (_t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    this._resizeDataWarning();\n  },\n  _updateLineEqualXY: function _updateLineEqualXY(duration) {\n    var oneMeasure = this.model.marker.axis_x.which == this.model.marker.axis_y.which;\n    this.lineEqualXY.classed(\"vzb-invisible\", !oneMeasure);\n    if (!oneMeasure) return;\n\n    var min = d3.min(this.yScale.domain().concat(this.xScale.domain()));\n    var max = d3.max(this.yScale.domain().concat(this.xScale.domain()));\n\n    this.lineEqualXY.transition().duration(duration || 0).attr(\"y1\", this.yScale(min)).attr(\"y2\", this.yScale(max)).attr(\"x1\", this.xScale(min)).attr(\"x2\", this.xScale(max));\n  },\n  _resizeDataWarning: function _resizeDataWarning() {\n    // reset font size to remove jumpy measurement\n    var dataWarningText = this.dataWarningEl.select(\"text\").style(\"font-size\", null);\n\n    // reduce font size if the caption doesn't fit\n    var dataWarningWidth = dataWarningText.node().getBBox().width + dataWarningText.node().getBBox().height * 3;\n    var remainingWidth = this.width - this.xTitleEl.node().getBBox().width - this.activeProfile.infoElHeight;\n    var font = parseInt(dataWarningText.style(\"font-size\")) * remainingWidth / dataWarningWidth;\n    dataWarningText.style(\"font-size\", dataWarningWidth > remainingWidth ? font + \"px\" : null);\n\n    // position the warning icon\n    var warnBB = dataWarningText.node().getBBox();\n    this.dataWarningEl.select(\"svg\").attr(\"width\", warnBB.height * 0.75).attr(\"height\", warnBB.height * 0.75).attr(\"x\", -warnBB.width - warnBB.height * 1.2).attr(\"y\", -warnBB.height * 0.65);\n\n    this.dataWarningEl.attr(\"transform\", \"translate(\" + (this.model.locale.isRTL() ? warnBB.width + warnBB.height : this.width) + \",\" + (this.height + this.activeProfile.margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\");\n  },\n  updateMarkerSizeLimits: function updateMarkerSizeLimits() {\n    var _this = this;\n    var extent = this.model.marker.size.extent || [0, 1];\n\n    if (!this.activeProfile) return utils.warn(\"updateMarkerSizeLimits() is called before ready(). This can happen if events get unfrozen and getFrame() still didn't return data\");\n\n    var minRadius = this.activeProfile.minRadiusPx;\n    var maxRadius = this.activeProfile.maxRadiusPx;\n\n    var minArea = utils.radiusToArea(Math.max(maxRadius * extent[0], minRadius));\n    var maxArea = utils.radiusToArea(Math.max(maxRadius * extent[1], minRadius));\n\n    var range = minArea === maxArea ? [minArea, maxArea] : d3.range(minArea, maxArea, (maxArea - minArea) / this.sScale.domain().length).concat(maxArea);\n\n    this.sScale.range(range);\n  },\n  redrawDataPointsOnlyColors: function redrawDataPointsOnlyColors() {\n    var _this = this;\n    if (!this.entityBubbles) return utils.warn(\"redrawDataPointsOnlyColors(): no entityBubbles defined. likely a premature call, fix it!\");\n\n    var valuesNow = void 0;\n    var KEY = this.KEY;\n\n    var time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, function (valuesLocked) {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function (d, index) {\n\n        var selected = _this.model.marker.isSelected(d);\n\n        var valueC = selected ? valuesNow.color[d[KEY]] : valuesLocked.color[d[KEY]];\n\n        var scaledC = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;\n\n        d3.select(this).style(\"fill\", scaledC);\n\n        //update lines of labels\n        if (selected) {\n\n          var select = utils.find(_this.model.marker.select, function (f) {\n            return f[KEY] == d[KEY];\n          });\n\n          var trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, function (valuesTrailStart) {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrames(). doing nothing\");\n\n            var cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledC0 = scaledC;\n            } else {\n              var _valueC = valuesTrailStart.color[d[KEY]];\n              cache.scaledC0 = _valueC != null ? _this.cScale(_valueC) : _this.COLOR_WHITEISH;\n            }\n\n            _this._labels.updateLabelOnlyColor(d, index, cache);\n          });\n        }\n      });\n    });\n  },\n  redrawDataPointsOnlySize: function redrawDataPointsOnlySize() {\n    var _this = this;\n\n    var valuesNow = void 0;\n    var KEY = this.KEY;\n\n    var time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, function (valuesLocked) {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function (d, index) {\n\n        var selected = _this.model.marker.isSelected(d);\n\n        var valueS = selected ? valuesNow.size[d[KEY]] : valuesLocked.size[d[KEY]];\n        if (valueS == null) return;\n\n        var scaledS = utils.areaToRadius(_this.sScale(valueS));\n        d3.select(this).attr(\"r\", scaledS);\n\n        //update lines of labels\n        if (selected) {\n\n          var select = utils.find(_this.model.marker.select, function (f) {\n            return f[KEY] == d[KEY];\n          });\n\n          var trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, function (valuesTrailStart) {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrames(). doing nothing\");\n\n            var cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledS0 = scaledS;\n            } else {\n              cache.scaledS0 = utils.areaToRadius(_this.sScale(valuesTrailStart.size[d[KEY]]));\n            }\n\n            _this._labels.updateLabelOnlyPosition(d, index, cache);\n          });\n        }\n      });\n    });\n  },\n\n\n  /*\n   * REDRAW DATA POINTS:\n   * Here plotting happens\n   * debouncing to improve performance: events might trigger it more than 1x\n   */\n  redrawDataPoints: function redrawDataPoints(duration) {\n    var _this = this;\n    var KEY = this.KEY;\n    if (duration == null) duration = _this.duration;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      var time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n\n      //get values for locked frames\n      this.model.marker.getFrame(time, function (lockedFrame) {\n        if (!lockedFrame) return utils.warn(\"redrawDataPoints: empty data received from marker.getFrames(). doing nothing\");\n\n        // each bubble\n        _this.entityBubbles.each(function (d, index) {\n          var frame = _this.model.marker.isSelected(d) ? _this.frame : lockedFrame;\n          _this._updateBubble(d, frame, index, d3.select(this), duration);\n        });\n      });\n    } else {\n      // each bubble\n      _this.entityBubbles.each(function (d, index) {\n        _this._updateBubble(d, _this.frame, index, d3.select(this), duration);\n      });\n    }\n\n    this._updateLineEqualXY(duration);\n  },\n\n\n  //redraw Data Points\n  _updateBubble: function _updateBubble(d, values, index, view, duration) {\n    var _this = this;\n    var KEY = this.KEY;\n\n    var showhide = false;\n\n    var valueY = values.axis_y[d[KEY]];\n    var valueX = values.axis_x[d[KEY]];\n    var valueS = values.size[d[KEY]];\n    var valueL = values.label[d[KEY]];\n    var valueC = values.color[d[KEY]];\n    var valueLST = values.size_label[d[KEY]];\n\n    // check if fetching data succeeded\n    if (!valueL && valueL !== 0 || !valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) {\n      // if entity is missing data it should hide\n      if (!d.hidden) {\n        d.hidden = true;\n        showhide = true;\n      }\n\n      if (showhide) {\n        if (duration) {\n          var opacity = view.style(\"opacity\");\n          view.transition().duration(duration).ease(d3.easeExp).style(\"opacity\", 0).on(\"end\", function () {\n            //to avoid transition from null state add class with a delay\n            view.classed(\"vzb-invisible\", d.hidden);\n            view.style(\"opacity\", opacity);\n          });\n        } else {\n          //immediately hide the bubble\n          view.classed(\"vzb-invisible\", d.hidden);\n        }\n      }\n    } else {\n      if (d.hidden || view.classed(\"vzb-invisible\")) {\n        d.hidden = false;\n        showhide = true;\n      }\n\n      // if entity has all the data we update the visuals\n      var scaledS = utils.areaToRadius(_this.sScale(valueS));\n\n      view.style(\"fill\", valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH);\n\n      if (duration) {\n        if (showhide) {\n          var _opacity = view.style(\"opacity\");\n          view.classed(\"vzb-invisible\", d.hidden);\n          view.style(\"opacity\", 0).attr(\"cy\", _this.yScale(valueY)).attr(\"cx\", _this.xScale(valueX)).attr(\"r\", scaledS).transition().duration(duration).ease(d3.easeExp).style(\"opacity\", _opacity);\n        } else {\n          view.transition().duration(duration).ease(d3.easeLinear).attr(\"cy\", _this.yScale(valueY)).attr(\"cx\", _this.xScale(valueX)).attr(\"r\", scaledS);\n        }\n      } else {\n\n        //interrupt the ongoing transition and immediately do the visual updates\n        view.interrupt().attr(\"cy\", _this.yScale(valueY)).attr(\"cx\", _this.xScale(valueX)).attr(\"r\", scaledS).transition();\n\n        //show entity if it was hidden\n        if (showhide) view.classed(\"vzb-invisible\", d.hidden);\n      }\n\n      if (this.model.time.record) _this._export.write({\n        type: \"circle\",\n        id: d[KEY],\n        time: this.model.time.value.getUTCFullYear(),\n        fill: valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH,\n        cx: _this.xScale(valueX),\n        cy: _this.yScale(valueY),\n        r: scaledS\n      });\n    } // data exists\n    _this._updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide);\n  },\n  _updateLabel: function _updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {\n    var _this = this;\n    var KEY = this.KEY;\n\n    // only for selected markers\n    if (_this.model.marker.isSelected(d)) {\n\n      var cache = {};\n\n      var select = utils.find(_this.model.marker.select, function (f) {\n        return f[KEY] == d[KEY];\n      });\n\n      var time = _this.model.time.formatDate(_this.time);\n      if (!this.model.ui.chart.trails || select.trailStartTime == time || select.trailStartTime == null) {\n        if (this.model.ui.chart.trails && select.trailStartTime == null) select.trailStartTime = time; // need only when trailStartTime == null\n\n        cache.labelX0 = valueX;\n        cache.labelY0 = valueY;\n        cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH, cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_this.sScale(valueS)) : null;\n      }\n\n      var trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n      var labelText = valueL + (_this.model.ui.chart.trails ? \" \" + select.trailStartTime : \"\");\n\n      if (showhide && d.hidden && _this.model.ui.chart.trails && trailStartTime && trailStartTime < _this.time) showhide = false;\n      if (d.hidden && !_this.model.ui.chart.trails) showhide = true;\n\n      this._labels.updateLabel(d, index, cache, valueX, valueY, valueS, valueC, labelText, valueLST, duration, showhide);\n    }\n  },\n  _formatSTitleValues: function _formatSTitleValues(titleS, titleC) {\n    var _this = this;\n    var unitS = this.strings.unit.S;\n    var unitC = this.strings.unit.C;\n\n    var formatterS = this.model.marker.size.getTickFormatter();\n    var formatterC = this.model.marker.color.getTickFormatter();\n\n    //resolve labels for colors via the color legend\n    if (this.model.marker.color.isDiscrete() && this.model.marker.color.use !== \"constant\" && titleC && this.model.marker.color.getColorlegendMarker()) {\n      titleC = this.model.marker.color.getColorlegendMarker().label.getItems()[titleC] || \"\";\n    }\n\n    return [formatterS(titleS) + \" \" + unitS, titleC || titleC === 0 ? formatterC(titleC) + \" \" + unitC : this.translator(\"hints/nodata\")];\n  },\n  _updateSTitle: function _updateSTitle(titleS, titleC) {\n\n    // vertical text about size and color\n    if (this.activeProfile.hideSTitle && this.model.ui.dialogs.sidebar.indexOf(\"colors\") > -1 && this.model.ui.dialogs.sidebar.indexOf(\"size\") > -1) {\n      this.sTitleEl.classed(\"vzb-invisible\", true);\n      return;\n    }\n    if (this.sTitleEl.classed(\"vzb-invisible\")) {\n      this.sTitleEl.classed(\"vzb-invisible\", false);\n    }\n    var sTitleContentON = this.model.marker.size.use !== \"constant\";\n    var cTitleContentON = this.model.marker.color.use !== \"constant\";\n    var sTitleText = this.sTitleEl.select(\"text\")\n    // reset font size to remove jumpy measurement\n    .style(\"font-size\", null).text((sTitleContentON ? this.translator(\"buttons/size\") + \": \" + (titleS ? titleS : this.strings.title.S) : \"\") + (sTitleContentON && cTitleContentON ? \", \" : \"\") + (cTitleContentON ? this.translator(\"buttons/colors\") + \": \" + (titleC ? titleC : this.strings.title.C) : \"\"));\n    var sTitleWidth = sTitleText.node().getBBox().width;\n    var remainigHeight = this.height - 30;\n    var font = parseInt(sTitleText.style(\"font-size\")) * remainigHeight / sTitleWidth;\n    sTitleText.style(\"font-size\", sTitleWidth > remainigHeight ? font + \"px\" : null);\n  },\n  selectDataPoints: function selectDataPoints() {\n    var _this = this;\n    var KEY = this.KEY;\n\n    if (utils.isTouchDevice()) {\n      _this.model.marker.clearHighlighted();\n      _this._labels.showCloseCross(null, false);\n    } else {\n      //hide tooltip\n      _this._setTooltip();\n      _this._setBubbleCrown();\n    }\n\n    _this.someSelected = _this.model.marker.select.length > 0;\n    _this.nonSelectedOpacityZero = false;\n  },\n  _setBubbleCrown: function _setBubbleCrown(x, y, r, glow, skipInnerFill) {\n    if (x != null) {\n      this.bubbleCrown.classed(\"vzb-hidden\", false);\n      this.bubbleCrown.select(\".vzb-crown\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", r).attr(\"fill\", skipInnerFill ? \"none\" : glow);\n      this.bubbleCrown.selectAll(\".vzb-crown-glow\").attr(\"cx\", x).attr(\"cy\", y).attr(\"r\", r + 10).attr(\"stroke\", glow);\n    } else {\n      this.bubbleCrown.classed(\"vzb-hidden\", true);\n    }\n  },\n  _setTooltip: function _setTooltip(tooltipText, x, y, offset, glow) {\n    if (tooltipText) {\n      var xPos = void 0,\n          yPos = void 0,\n          xSign = -1,\n          ySign = -1,\n          xOffset = 0,\n          yOffset = 0;\n\n      if (offset) {\n        xOffset = offset * 0.71; // .71 - sin and cos for 315\n        yOffset = offset * 0.71;\n      }\n      //position tooltip\n      this.tooltip.classed(\"vzb-hidden\", false)\n      //.attr(\"style\", \"left:\" + (mouse[0] + 50) + \"px;top:\" + (mouse[1] + 50) + \"px\")\n      .selectAll(\"text\").text(tooltipText);\n\n      var contentBBox = this.tooltip.select(\"text\").node().getBBox();\n      if (x - xOffset - contentBBox.width < 0) {\n        xSign = 1;\n        x += contentBBox.width + 5; // corrective to the block Radius and text padding\n      } else {\n        x -= 5; // corrective to the block Radius and text padding\n      }\n      if (y - yOffset - contentBBox.height < 0) {\n        ySign = 1;\n        y += contentBBox.height;\n      } else {\n        y -= 11; // corrective to the block Radius and text padding\n      }\n      if (offset) {\n        xPos = x + xOffset * xSign;\n        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding\n      } else {\n        xPos = x + xOffset * xSign; // .71 - sin and cos for 315\n        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding\n      }\n      this.tooltip.attr(\"transform\", \"translate(\" + xPos + \",\" + yPos + \")\");\n\n      this.tooltip.selectAll(\"rect\").attr(\"width\", contentBBox.width + 8).attr(\"height\", contentBBox.height * 1.2).attr(\"x\", -contentBBox.width - 4).attr(\"y\", -contentBBox.height * 0.85).attr(\"rx\", contentBBox.height * 0.2).attr(\"ry\", contentBBox.height * 0.2);\n\n      this.tooltip.select(\".vzb-tooltip-glow\").attr(\"stroke\", glow);\n    } else {\n      this.tooltip.classed(\"vzb-hidden\", true);\n    }\n  },\n\n\n  /*\n   * Shows and hides axis projections\n   */\n  _axisProjections: function _axisProjections(d) {\n    var _this = this;\n    var TIMEDIM = this.TIMEDIM;\n    var KEY = this.KEY;\n\n    if (d != null) {\n\n      this.model.marker.getFrame(d[TIMEDIM], function (values) {\n        var valueY = values.axis_y[d[KEY]];\n        var valueX = values.axis_x[d[KEY]];\n        var valueS = values.size[d[KEY]];\n        var radius = utils.areaToRadius(_this.sScale(valueS));\n\n        if (!valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) return;\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineX && _this.xScale(valueX) > 0 && _this.xScale(valueX) < _this.width && _this.yScale(valueY) + radius < _this.height) {\n          _this.projectionX.style(\"opacity\", 1).attr(\"y2\", _this.yScale(valueY) + radius).attr(\"x1\", _this.xScale(valueX)).attr(\"x2\", _this.xScale(valueX));\n        }\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineY && _this.yScale(valueY) > 0 && _this.yScale(valueY) < _this.height && _this.xScale(valueX) - radius > 0) {\n          _this.projectionY.style(\"opacity\", 1).attr(\"y1\", _this.yScale(valueY)).attr(\"y2\", _this.yScale(valueY)).attr(\"x1\", _this.xScale(valueX) - radius);\n        }\n\n        if (_this.model.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(_this.xAxis.highlightValue(valueX));\n\n        if (_this.model.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(_this.yAxis.highlightValue(valueY));\n      });\n    } else {\n\n      this.projectionX.style(\"opacity\", 0);\n      this.projectionY.style(\"opacity\", 0);\n      this.xAxisEl.call(this.xAxis.highlightValue(\"none\"));\n      this.yAxisEl.call(this.yAxis.highlightValue(\"none\"));\n    }\n  },\n\n\n  /*\n   * Highlights all hovered bubbles\n   */\n  highlightDataPoints: function highlightDataPoints() {\n    var _this = this;\n    var TIMEDIM = this.TIMEDIM;\n    var KEY = this.KEY;\n\n    this.someHighlighted = this.model.marker.highlight.length > 0;\n\n    this.updateBubbleOpacity();\n\n    if (this.model.marker.highlight.length === 1) {\n      var d = utils.clone(this.model.marker.highlight[0]);\n\n      if (_this.model.ui.chart.lockNonSelected && _this.someSelected && !_this.model.marker.isSelected(d)) {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + _this.model.ui.chart.lockNonSelected);\n      } else {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + d.trailStartTime) || _this.time;\n      }\n\n      _this.model.marker.getFrame(d[TIMEDIM], function (values) {\n        if (!values) return;\n        var x = _this.xScale(values.axis_x[d[KEY]]);\n        var y = _this.yScale(values.axis_y[d[KEY]]);\n        var s = utils.areaToRadius(_this.sScale(values.size[d[KEY]]));\n        var c = values.color[d[KEY]] != null ? _this.cScale(values.color[d[KEY]]) : _this.COLOR_WHITEISH;\n        var entityOutOfView = false;\n\n        var titles = _this._formatSTitleValues(values.size[d[KEY]], values.color[d[KEY]]);\n        _this._updateSTitle(titles[0], titles[1]);\n        if (x + s < 0 || x - s > _this.width || y + s < 0 || y - s > _this.height) {\n          entityOutOfView = true;\n        }\n\n        //show tooltip\n        var text = \"\";\n        var hoverTrail = false;\n        if (_this.model.marker.isSelected(d) && _this.model.ui.chart.trails) {\n          text = _this.model.time.formatDate(_this.time);\n          var _selectedData = utils.find(_this.model.marker.select, function (f) {\n            return f[KEY] == d[KEY];\n          });\n          hoverTrail = text !== _selectedData.trailStartTime && !d3.select(d3.event.target).classed(\"bubble-\" + d[KEY]);\n          text = text !== _selectedData.trailStartTime && _this.time === d[TIMEDIM] ? text : \"\";\n        } else {\n          text = _this.model.marker.isSelected(d) ? \"\" : values.label[d[KEY]];\n        }\n\n        _this._labels.highlight(null, false);\n        _this._labels.highlight(d, true);\n        if (_this.model.marker.isSelected(d)) {\n          var skipCrownInnerFill = !d.trailStartTime || d.trailStartTime == _this.model.time.formatDate(_this.time);\n          _this._setBubbleCrown(x, y, s, c, skipCrownInnerFill);\n        }\n\n        if (!entityOutOfView && !hoverTrail) {\n          _this._axisProjections(d);\n        }\n\n        //set tooltip and show axis projections\n        if (text && !entityOutOfView && !hoverTrail) {\n          _this._setTooltip(text, x, y, s + 3, c);\n        }\n\n        var selectedData = utils.find(_this.model.marker.select, function (f) {\n          return f[KEY] == d[KEY];\n        });\n        if (selectedData) {\n          var clonedSelectedData = utils.clone(selectedData);\n          //change opacity to OPACITY_HIGHLT = 1.0;\n          clonedSelectedData.opacity = 1.0;\n          _this._trails.run([\"opacityHandler\"], clonedSelectedData);\n        }\n      });\n    } else {\n      this._axisProjections();\n      this._trails.run([\"opacityHandler\"]);\n      //hide tooltip\n      _this._updateSTitle();\n      this._setTooltip();\n      this._setBubbleCrown();\n      this._labels.highlight(null, false);\n    }\n  },\n  updateBubbleOpacity: function updateBubbleOpacity(duration) {\n    var _this = this;\n    //if(!duration)duration = 0;\n\n    var OPACITY_HIGHLT = 1.0;\n    var OPACITY_HIGHLT_DIM = this.model.marker.opacityHighlightDim;\n    var OPACITY_SELECT = this.model.marker.opacityRegular;\n    var OPACITY_REGULAR = this.model.marker.opacityRegular;\n    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;\n\n    this.entityBubbles\n    //.transition().duration(duration)\n    .style(\"opacity\", function (d) {\n\n      if (_this.someHighlighted) {\n        //highlight or non-highlight\n        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;\n      }\n\n      if (_this.someSelected) {\n        //selected or non-selected\n        return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;\n      }\n\n      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;\n\n      return OPACITY_REGULAR;\n    });\n\n    var nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n\n    // when pointer events need update...\n    if (nonSelectedOpacityZero != this.nonSelectedOpacityZero) {\n      this.entityBubbles.style(\"pointer-events\", function (d) {\n        return !_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d) ? \"visible\" : \"none\";\n      });\n    }\n\n    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n  }\n});\n\nexports.default = BubbleChart;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _Vizabi = Vizabi,\n    utils = _Vizabi.utils;\n\n\nvar PanZoom = Vizabi.Class.extend({\n  init: function init(context) {\n    this.context = context;\n\n    this.dragRectangle = d3.drag();\n    this.zoomer = d3.zoom();\n\n    // this.dragLock = false;\n\n    this.dragRectangle.subject(this.dragSubject()).on(\"start\", this.drag().start).on(\"drag\", this.drag().go).on(\"end\", this.drag().stop);\n\n    this.zoomer.filter(this.zoomFilter()).scaleExtent([0.0625, +Infinity]).on(\"start\", this.zoom().start).on(\"zoom\", this.zoom().go).on(\"end\", this.zoom().stop);\n\n    this.zoomer.ratioX = 1;\n    this.zoomer.ratioY = 1;\n\n    context._zoomedXYMinMax = {\n      axis_x: { zoomedMin: null, zoomedMax: null },\n      axis_y: { zoomedMin: null, zoomedMax: null }\n    };\n  },\n  dragSubject: function dragSubject() {\n    var _this = this.context;\n    var self = this;\n\n    return function (d) {\n      /*\n       * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n       * not enabled. Also do not drag if zoom-pinching on touchmove\n       * events.\n       */\n      if (!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey || _this.ui.cursorMode === \"plus\") || _this.ui.cursorMode === \"minus\" || (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") && (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        return null;\n      }\n\n      return {\n        x: d3.mouse(this)[0],\n        y: d3.mouse(this)[1]\n      };\n    };\n  },\n  drag: function drag() {\n    var _this = this.context;\n    var self = this;\n\n    return {\n      start: function start(d, i) {\n        /*\n         * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n         * not enabled. Also do not drag if zoom-pinching on touchmove\n         * events.\n         */\n        //   if(!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||\n        //          _this.ui.cursorMode === \"plus\") ||\n        //          (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //          (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //         return;\n        //     }\n\n        // self.dragLock = true;\n        this.origin = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        _this.zoomRect.classed(\"vzb-invisible\", false);\n      },\n      go: function go(d, i) {\n        /*\n         * Cancel drag if drag lock is false, or when zoom-pinching via\n         * touchmove events.\n         */\n        // if (!self.dragLock || (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //             (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n\n        //   _this.zoomRect\n        //     .attr(\"width\", 0)\n        //     .attr(\"height\", 0)\n        //     .classed(\"vzb-invisible\", true);\n\n        //   return;\n        // }\n\n        var origin = this.origin;\n        var mouse = {\n          x: d3.event.x,\n          y: d3.event.y\n        };\n\n        _this.zoomRect.attr(\"x\", Math.min(mouse.x, origin.x)).attr(\"y\", Math.min(mouse.y, origin.y)).attr(\"width\", Math.abs(mouse.x - origin.x)).attr(\"height\", Math.abs(mouse.y - origin.y));\n      },\n      stop: function stop(e) {\n        // if (!self.dragLock) return;\n        // self.dragLock = false;\n\n        _this.zoomRect.attr(\"width\", 0).attr(\"height\", 0).classed(\"vzb-invisible\", true);\n\n        this.target = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        if (Math.abs(this.origin.x - this.target.x) < 10 || Math.abs(this.origin.y - this.target.y) < 10) return;\n\n        /*\n         * Only compensate for dragging when the Ctrl key or Meta key\n         * are pressed, or if the cursorMode is not in plus mode.\n         */\n        var compensateDragging = d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey || _this.ui.cursorMode === \"plus\";\n\n        self._zoomOnRectangle(d3.select(this), this.origin.x, this.origin.y, this.target.x, this.target.y, compensateDragging, 500);\n      }\n    };\n  },\n  zoomFilter: function zoomFilter() {\n    var _this = this.context;\n    var self = this;\n\n    return function (d) {\n      var event = d3.event;\n\n      if (event.ctrlKey || event.metaKey) return false;\n\n      // Cancel drag lock when zoom-pinching via touchmove events.\n      if ((event.type === \"touchmove\" || event.type === \"touchstart\") && (event.touches.length > 1 || event.targetTouches.length > 1)) return true;\n\n      if ((event.type === \"wheel\" || event.type === \"mousewheel\") && _this.ui.zoomOnScrolling) {\n        // if (_this.scrollableAncestor) {\n        //   _this.scrollableAncestor.scrollTop -= (event.deltaY || -event.wheelDelta);\n        // }\n        // d3.event.scale = null;\n        //zoomer.scale(this.savedScale);\n        return true;\n      }\n\n      if ((event.type === \"mousedown\" || event.type === \"touchstart\") && _this.ui.cursorMode !== \"plus\" && _this.ui.cursorMode !== \"minus\" && (_this.ui.panWithArrow || _this.ui.cursorMode === \"hand\")) return true;\n\n      return false;\n    };\n  },\n  zoom: function zoom() {\n    var _this = this.context;\n    var zoomer = this.zoomer;\n    var self = this;\n\n    return {\n      start: function start() {\n        //this.savedScale = zoomer.scale;\n        if (_this.ui.cursorMode !== \"plus\" && _this.ui.cursorMode !== \"minus\") {\n          _this.chartSvg.classed(\"vzb-zooming\", true);\n        }\n\n        _this.model._data.marker.clearHighlighted();\n        _this._setTooltip();\n      },\n      go: function go() {\n\n        var sourceEvent = d3.event.sourceEvent;\n\n        //if (sourceEvent != null && (sourceEvent.ctrlKey || sourceEvent.metaKey)) return;\n\n        // Cancel drag lock when zoom-pinching via touchmove events.\n        // if (sourceEvent !== null &&\n        //             (sourceEvent.type === \"touchmove\" || sourceEvent.type === \"touchstart\") &&\n        //             (sourceEvent.touches.length > 1 || sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n        // }\n\n        //if (self.dragLock) return;\n\n        //send the event to the page if fully zoomed our or page not scrolled into view\n        //\n        //                    if(d3.event.scale == 1)\n        //\n        //                    if(utils.getViewportPosition(_this.element.node()).y < 0 && d3.event.scale > 1) {\n        //                        _this.scrollableAncestor.scrollTop += d3.event.sourceEvent.deltaY;\n        //                        return;\n        //                    }\n        /*\n         * Do not zoom on the chart if the scroll event is a wheel\n         * scroll. Instead, redirect the scroll event to the scrollable\n         * ancestor\n         */\n        // if (sourceEvent != null && (sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") &&\n        //             !_this.ui.zoomOnScrolling) {\n        //   if (_this.scrollableAncestor) {\n        //     _this.scrollableAncestor.scrollTop += (sourceEvent.deltaY || -sourceEvent.wheelDelta);\n        //   }\n        //   d3.event.scale = null;\n        //             //zoomer.scale(this.savedScale);\n        //   this.quitZoom = true;\n        //   return;\n        // }\n        // this.quitZoom = false;\n\n        //_this.model._data.marker.clearHighlighted();\n        //_this._setTooltip();\n\n        //var transform = d3.zoomTransform(self.zoomSelection.node())\n        //  .translate(, )\n        //.scale(d3.event.transform.k);\n        var zoom = d3.event.transform.k;\n\n        var pan = [d3.event.transform.x, d3.event.transform.y]; //d3.event.translate;\n        var ratioY = zoomer.ratioY;\n        var ratioX = zoomer.ratioX;\n\n        _this.draggingNow = true;\n\n        //value protections and fallbacks\n        if (isNaN(zoom) || zoom == null) zoom = zoomer.scale;\n        if (isNaN(zoom) || zoom == null) zoom = 1;\n\n        //TODO: this is a patch to fix #221. A proper code review of zoom and zoomOnRectangle logic is needed\n        /*\n         * Mouse wheel and touchmove events set the zoom value\n         * independently of axis ratios. If the zoom event was triggered\n         * by a mouse wheel event scrolling down or touchmove event with\n         * more than 1 contact that sets zoom to 1, then set the axis\n         * ratios to 1 as well, which will fully zoom out.\n         */\n        if (zoom === 1 && sourceEvent !== null && ((sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") && (sourceEvent.deltaY || -sourceEvent.wheelDelta) > 0 || sourceEvent.type === \"touchmove\" && sourceEvent.touches.length > 1)) {\n          zoomer.ratioX = 1;\n          ratioX = 1;\n          zoomer.ratioY = 1;\n          ratioY = 1;\n        }\n\n        //                if(isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = zoomer.translate();\n        if (isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = [0, 0];\n\n        // limit the zooming, so that it never goes below min value of zoom for any of the axes\n        var minZoomScale = zoomer.scaleExtent()[0];\n        if (zoom * ratioY < minZoomScale) {\n          ratioY = minZoomScale / zoom;\n          zoomer.ratioY = ratioY;\n        }\n        if (zoom * ratioX < minZoomScale) {\n          ratioX = minZoomScale / zoom;\n          zoomer.ratioX = ratioX;\n        }\n\n        var zoomXOut = zoom * ratioX < 1;\n        var zoomYOut = zoom * ratioY < 1;\n\n        //limit the panning, so that we are never outside the possible range\n        if (!zoomXOut) {\n          if (pan[0] > 0) pan[0] = 0;\n          if (pan[0] < (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        } else {\n          if (pan[0] < 0) pan[0] = 0;\n          if (pan[0] > (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        }\n\n        if (!zoomYOut) {\n          if (pan[1] > 0) pan[1] = 0;\n          if (pan[1] < (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        } else {\n          if (pan[1] < 0) pan[1] = 0;\n          if (pan[1] > (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        }\n\n        //limit zoom translate\n        self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        var xPanOffset = _this.width * zoom * ratioX;\n        var yPanOffset = _this.height * zoom * ratioY;\n\n        var xRange = [0 * zoom * ratioX + pan[0], xPanOffset + pan[0]];\n        var yRange = [yPanOffset + pan[1], 0 * zoom * ratioY + pan[1]];\n\n        var xRangeBumped = _this._rangeBump(xRange);\n        var yRangeBumped = _this._rangeBump(yRange);\n\n        /*\n         * Shift xRange and yRange by the difference between the bumped\n         * ranges, which is scaled by the zoom factor. This accounts for\n         * the range bump, which controls a gutter around the\n         * bubblechart, while correctly zooming.\n         */\n        var xRangeMinOffset = (xRangeBumped[0] - xRange[0]) * zoom * ratioX;\n        var xRangeMaxOffset = (xRangeBumped[1] - xRange[1]) * zoom * ratioX;\n\n        var yRangeMinOffset = (yRangeBumped[0] - yRange[0]) * zoom * ratioY;\n        var yRangeMaxOffset = (yRangeBumped[1] - yRange[1]) * zoom * ratioY;\n\n        xRange[0] += xRangeMinOffset;\n        xRange[1] += xRangeMaxOffset;\n\n        yRange[0] += yRangeMinOffset;\n        yRange[1] += yRangeMaxOffset;\n\n        // Calculate the maximum xRange and yRange available.\n        var xRangeBounds = [0, _this.width];\n        var yRangeBounds = [_this.height, 0];\n\n        var xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n        var yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n        /*\n         * Set the pan to account for the range bump by subtracting\n         * offsets and preventing panning past the range bump gutter.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] < xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] > xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] > yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] < yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        }\n\n        //zoomer.translate = pan;\n        //self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        /*\n         * Clamp the xRange and yRange by the amount that the bounds\n         * that are range bumped.\n         *\n         * Additionally, take the amount clamped on the end of the range\n         * and either subtract or add it to the range's other end. This\n         * prevents visible stretching of the range when only panning.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) {\n            xRange[1] -= Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] < xRangeBoundsBumped[1]) {\n            xRange[0] += Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) {\n            xRange[1] += Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] > xRangeBoundsBumped[1]) {\n            xRange[0] -= Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) {\n            yRange[1] += Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] > yRangeBoundsBumped[1]) {\n            yRange[0] -= Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) {\n            yRange[1] -= Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] < yRangeBoundsBumped[1]) {\n            yRange[0] += Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        }\n\n        if (_this.model.marker.axis_x.scaleType === \"ordinal\") {\n          _this.xScale.rangeBands(xRange);\n        } else {\n          _this.xScale.range(xRange);\n        }\n\n        if (_this.model.marker.axis_y.scaleType === \"ordinal\") {\n          _this.yScale.rangeBands(yRange);\n        } else {\n          _this.yScale.range(yRange);\n        }\n\n        var formatter = function formatter(n) {\n          return utils.isDate(n) ? n : d3.round(n, 2);\n        };\n\n        var zoomedXRange = xRangeBoundsBumped;\n        var zoomedYRange = yRangeBoundsBumped;\n\n        /*\n         * Set the zoomed min/max to the correct value depending on if the\n         * min/max values lie within the range bound regions.\n         */\n        /*\n         if(!zoomXOut) {\n         zoomedXRange[0] = xRangeBounds[0] > xRange[0] ? xRangeBounds[0] : xRange[0];\n         zoomedXRange[1] = xRangeBounds[1] < xRange[1] ? xRangeBounds[1] : xRange[1];\n         }\n          if(!zoomYOut) {\n         zoomedYRange[0] = yRangeBounds[0] < yRange[0] ? yRangeBounds[0] : yRange[0];\n         zoomedYRange[1] = yRangeBounds[1] > yRange[1] ? yRangeBounds[1] : yRange[1];\n         }\n         */\n\n        _this._zoomedXYMinMax = {\n          axis_x: {\n            zoomedMin: formatter(_this.xScale.invert(zoomedXRange[0])),\n            zoomedMax: formatter(_this.xScale.invert(zoomedXRange[1]))\n          },\n          axis_y: {\n            zoomedMin: formatter(_this.yScale.invert(zoomedYRange[0])),\n            zoomedMax: formatter(_this.yScale.invert(zoomedYRange[1]))\n          }\n        };\n\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, null, false /*avoid storing it in URL*/);\n\n        var optionsY = _this.yAxis.labelerOptions();\n        var optionsX = _this.xAxis.labelerOptions();\n        optionsY.limitMaxTickNumber = zoom * ratioY < 1.5 ? 8 : zoom * ratioY * 8;\n        optionsX.limitMaxTickNumber = zoom * ratioX < 1.5 ? 8 : zoom * ratioX * 8;\n        optionsY.transitionDuration = zoomer.duration;\n        optionsX.transitionDuration = zoomer.duration;\n\n        _this.xAxisEl.call(_this.xAxis.labelerOptions(optionsX));\n        _this.yAxisEl.call(_this.yAxis.labelerOptions(optionsY));\n        _this.redrawDataPoints(zoomer.duration);\n        _this._trails.run(\"resize\", null, zoomer.duration);\n\n        zoomer.duration = 0;\n      },\n      stop: function stop() {\n        _this.chartSvg.classed(\"vzb-zooming\", false);\n\n        _this.draggingNow = false;\n\n        // if (this.quitZoom) return;\n\n        //Force the update of the URL and history, with the same values\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, true, true);\n        zoomer.dontFeedToState = null;\n      }\n    };\n  },\n  expandCanvas: function expandCanvas(duration) {\n    var _this = this.context;\n    if (!duration) duration = _this.duration;\n\n    //d3 extent returns min and max of the input array as [min, max]\n    var mmX = d3.extent(utils.values(_this.frame.axis_x));\n    var mmY = d3.extent(utils.values(_this.frame.axis_y));\n\n    //protection agains unreasonable min-max results -- abort function\n    if (!mmX[0] && mmX[0] !== 0 || !mmX[1] && mmX[1] !== 0 || !mmY[0] && mmY[0] !== 0 || !mmY[1] && mmY[1] !== 0) {\n      return utils.warn(\"panZoom.expandCanvas: X or Y min/max are broken. Aborting with no action\");\n    }\n    /*\n     * Use a range bumped scale to correctly accommodate the range bump\n     * gutter.\n     */\n    var suggestedFrame = {\n      x1: _this.xScale(mmX[0]),\n      y1: _this.yScale(mmY[0]),\n      x2: _this.xScale(mmX[1]),\n      y2: _this.yScale(mmY[1])\n    };\n    var xBounds = [0, _this.width];\n    var yBounds = [_this.height, 0];\n\n    // Get the current zoom frame based on the current dimensions.\n    var frame = {\n      x1: xBounds[0],\n      x2: xBounds[1],\n      y1: yBounds[0],\n      y2: yBounds[1]\n    };\n\n    var TOLERANCE = 0.0;\n\n    /*\n     * If there is no current zoom frame, or if any of the suggested frame\n     * points extend outside of the current zoom frame, then expand the\n     * canvas.\n     */\n    if (!_this.isCanvasPreviouslyExpanded || suggestedFrame.x1 < frame.x1 * (1 - TOLERANCE) || suggestedFrame.x2 > frame.x2 * (1 + TOLERANCE) || suggestedFrame.y2 < frame.y2 * (1 - TOLERANCE) || suggestedFrame.y1 > frame.y1 * (1 + TOLERANCE)) {\n      /*\n       * If there is already a zoom frame, then clamp the suggested frame\n       * points to only zoom out and expand the canvas.\n       *\n       * If any of x1, x2, y1, or y2 is within the current frame\n       * boundaries, then clamp them to the frame boundaries. If any of\n       * the above values will translate into a data value that is outside\n       * of the possible data range, then clamp them to the frame\n       * coordinate that corresponds to the maximum data value that can\n       * be displayed.\n       */\n      if (_this.isCanvasPreviouslyExpanded) {\n        /*\n         * Calculate bounds and bumped scale for calculating the data boundaries\n         * to which the suggested frame points need to be clamped.\n         */\n        var xBoundsBumped = _this._rangeBump(xBounds);\n        var yBoundsBumped = _this._rangeBump(yBounds);\n\n        if (suggestedFrame.x1 > xBoundsBumped[0]) suggestedFrame.x1 = xBoundsBumped[0];\n        if (suggestedFrame.x2 < xBoundsBumped[1]) suggestedFrame.x2 = xBoundsBumped[1];\n        if (suggestedFrame.y1 < yBoundsBumped[0]) suggestedFrame.y1 = yBoundsBumped[0];\n        if (suggestedFrame.y2 > yBoundsBumped[0]) suggestedFrame.y2 = yBoundsBumped[1];\n      }\n\n      _this.isCanvasPreviouslyExpanded = true;\n      this._zoomOnRectangle(_this.element, suggestedFrame.x1, suggestedFrame.y1, suggestedFrame.x2, suggestedFrame.y2, false, duration);\n    } else {\n      _this.redrawDataPoints(duration);\n    }\n  },\n  zoomToMaxMin: function zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, duration, dontFeedToState) {\n    var _this = this.context;\n    var minX = zoomedMinX;\n    var maxX = zoomedMaxX;\n    var minY = zoomedMinY;\n    var maxY = zoomedMaxY;\n\n    var xDomain = _this.xScale.domain();\n    var yDomain = _this.yScale.domain();\n\n    /*\n     * Prevent zoomout if only one of zoom edges set outside domain\n     */\n    if (minX < xDomain[0] && maxX < xDomain[1]) minX = xDomain[0];\n    if (minX > xDomain[0] && maxX > xDomain[1]) maxX = xDomain[1];\n    if (minY < yDomain[0] && maxY < yDomain[1]) minY = yDomain[0];\n    if (minY > yDomain[0] && maxY > yDomain[1]) maxY = yDomain[1];\n\n    var xRange = [_this.xScale(minX), _this.xScale(maxX)];\n    var yRange = [_this.yScale(minY), _this.yScale(maxY)];\n\n    this._zoomOnRectangle(_this.element, xRange[0], yRange[0], xRange[1], yRange[1], false, duration, dontFeedToState);\n  },\n  _zoomOnRectangle: function _zoomOnRectangle(element, zoomedX1, zoomedY1, zoomedX2, zoomedY2, compensateDragging, duration, dontFeedToState) {\n    var _this = this.context;\n    var zoomer = this.zoomer;\n    var transform = d3.zoomTransform(this.zoomSelection.node());\n\n    var x1 = zoomedX1;\n    var y1 = zoomedY1;\n    var x2 = zoomedX2;\n    var y2 = zoomedY2;\n\n    /*\n     * When dragging to draw a rectangle, the translate vector has (x2 - x1)\n     * added to zoomer.translate()[0], and (y2 - 1) added to\n     * zoomer.translate()[1].\n     *\n     * We need to compensate for this addition when\n     * zooming with a rectangle, because zooming with a rectangle will\n     * update the translate vector with new values based on the rectangle\n     * dimensions.\n     */\n    if (compensateDragging) {\n      transform.translate(x1 - x2, y1 - y2);\n      // zoomer.translate([\n      //     zoomer.translate()[0] + x1 - x2,\n      //     zoomer.translate()[1] + y1 - y2\n      // ]);\n    }\n\n    var xRangeBounds = [0, _this.width];\n    var yRangeBounds = [_this.height, 0];\n\n    var xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n    var yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n    var minZoom = zoomer.scaleExtent()[0];\n    var maxZoom = zoomer.scaleExtent()[1];\n    var zoom = void 0,\n        ratioX = void 0,\n        ratioY = void 0;\n\n    if (x1 == x2 || y1 == y2 || xRangeBoundsBumped[0] == xRangeBoundsBumped[1] || yRangeBoundsBumped[0] == yRangeBoundsBumped[1]) {\n      return utils.warn(\"_zoomOnRectangle(): can not proceed because this may result in infinity zooms\");\n    }\n\n    if (Math.abs(x1 - x2) > Math.abs(y1 - y2)) {\n      zoom = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioY *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioX = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k / zoom * zoomer.ratioX;\n      ratioY = zoomer.ratioY;\n    } else {\n      zoom = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioX *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioY = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k / zoom * zoomer.ratioY;\n      ratioX = zoomer.ratioX;\n    }\n\n    var pan = [(transform.x - Math.min(x1, x2)) / transform.k / zoomer.ratioX * zoom * ratioX + (xRangeBoundsBumped[0] - xRangeBounds[0]), (transform.y - Math.min(y1, y2)) / transform.k / zoomer.ratioY * zoom * ratioY + (yRangeBoundsBumped[1] - yRangeBounds[1])];\n\n    zoomer.dontFeedToState = dontFeedToState;\n    //zoomer.scale(zoom);\n    zoomer.ratioY = ratioY || 1; //NaN defaults to 1\n    zoomer.ratioX = ratioX || 1; //NaN defaults to 1\n    //zoomer.translate(pan);\n    zoomer.duration = duration ? duration : 0;\n\n    //zoomer.event(element);\n    this.zoomSelection.call(zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n  },\n\n\n  /*\n   * Incrementally zoom in or out and pan the view so that it never looses the point where click happened\n   * this function is a modified d3's own zoom behavior on double click\n   * for the original code see https://github.com/mbostock/d3/blob/master/src/behavior/zoom.js\n   * function dblclicked() and what it refers to\n   */\n  zoomByIncrement: function zoomByIncrement(direction, duration) {\n    var _this = this.context;\n    var transform = d3.zoomTransform(this.zoomSelection.node());\n\n    var ratio = transform.k;\n    var pan = [transform.x, transform.y];\n\n    var mouse = d3.mouse(this.zoomSelection.node());\n    var k = Math.log(ratio) / Math.LN2;\n\n    //change factor direction based on the input. default is no direction supplied\n    if (direction == \"plus\" || !direction) k = Math.floor(k) + 1;\n    if (direction == \"minus\") k = Math.ceil(k) - 1;\n\n    //decode panning\n    var locus = [(mouse[0] - pan[0]) / ratio, (mouse[1] - pan[1]) / ratio];\n\n    //recalculate zoom ratio\n    var scaleExtent = this.zoomer.scaleExtent();\n    if (ratio == scaleExtent[0]) {\n      this.zoomer.ratioY = 1;\n      this.zoomer.ratioX = 1;\n    }\n    ratio = Math.max(scaleExtent[0], Math.min(scaleExtent[1], Math.pow(2, k)));\n\n    //recalculate panning\n    locus = [locus[0] * ratio + pan[0], locus[1] * ratio + pan[1]];\n    pan[0] += mouse[0] - locus[0];\n    pan[1] += mouse[1] - locus[1];\n\n    //save changes to the zoom behavior and run the event\n    //this.zoomer.scale(ratio);\n    //this.zoomer.translate([pan[0], pan[1]]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(_this.element);\n    this.zoomSelection.call(this.zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(ratio));\n  },\n\n\n  /*\n   * Reset zoom values without triggering a zoom event.\n   */\n  resetZoomState: function resetZoomState(element) {\n    //this.zoomer.scaleTo(element, 1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    (element || this.zoomSelection).property(\"__zoom\", d3.zoomIdentity);\n  },\n  reset: function reset(element, duration) {\n    var _this = this.context;\n    _this.isCanvasPreviouslyExpanded = false;\n\n    //this.zoomer.scale(1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.transform, d3.zoomIdentity);\n  },\n  rerun: function rerun(element) {\n    var _this = this.context;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.scaleBy, 1);\n  },\n  zoomSelection: function zoomSelection(element) {\n    this.zoomSelection = element;\n  }\n});\n\nexports.default = PanZoom;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _css = __webpack_require__(4);\n\nvar _css2 = _interopRequireDefault(_css);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _Vizabi = Vizabi,\n    utils = _Vizabi.utils;\n\n\nvar Trail = Vizabi.Class.extend({\n  init: function init(context) {\n    this.context = context;\n    this._isCreated = null;\n    this.actionsQueue = {};\n    this.entityTrails = {};\n    this.trailsData = [];\n    this.trailsInProgress = {};\n    this.activePromises = {};\n    this.trailTransitions = {};\n    this.delayedIterations = {};\n    this.drawingQueue = {};\n  },\n  toggle: function toggle(arg) {\n    var _context = this.context;\n    if (arg) {\n\n      _context._trails.create().then(function () {\n        _context._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      });\n    } else {\n      _context._trails.run(\"remove\");\n      _context.model.marker.select.forEach(function (d) {\n        d.trailStartTime = null;\n      });\n    }\n  },\n  create: function create(selection) {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n    var TIMEDIM = _context.TIMEDIM;\n    this._isCreated = new Promise(function (resolve, reject) {\n      //quit if the function is called accidentally\n      if (!_context.model.ui.chart.trails) return;\n\n      var timePoints = _context.model.time.getAllSteps();\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      var promises = [];\n      selection = selection == null ? _context.model.marker.select : [selection];\n      _this._clearActions(selection);\n      _this.trailsData = _context.model.marker.select.map(function (d) {\n        var r = {\n          status: \"created\",\n          selectedEntityData: d\n        };\n        r[KEY] = d[KEY];\n        return r;\n      });\n      _this.trailTransitions = {};\n      var _trails = _context.bubbleContainer.selectAll(\"g.vzb-bc-entity.entity-trail\").data(_this.trailsData, function (d) {\n        return d[KEY];\n      });\n\n      _trails.exit().remove();\n      _trails.enter().insert(\"g\", function (d) {\n        return this.querySelector(\".bubble-\" + (0, _css2.default)(d[KEY]));\n      }).attr(\"class\", function (d) {\n        return \"vzb-bc-entity entity-trail trail-\" + d[KEY];\n      }).merge(_trails).each(function (d, index) {\n        // used for prevent move trail start time forward when we have empty values at end of time range\n        var trail = this;\n        promises.push(new Promise(function (resolve, reject) {\n          var trailSegmentData = timePoints.map(function (m) {\n            return {\n              t: m,\n              key: d[KEY]\n            };\n          });\n          var entityTrails = d3.select(trail).selectAll(\"g\").data(trailSegmentData).classed(\"vzb-invisible\", true);\n\n          entityTrails.exit().remove();\n\n          _this.entityTrails[d[KEY]] = entityTrails.enter().append(\"g\").attr(\"class\", \"vzb-bc-trailsegment\").on(\"mouseover\", function (segment, index) {\n            if (utils.isTouchDevice()) return;\n\n            var pointer = {};\n            pointer[KEY] = segment.key;\n            pointer[TIMEDIM] = segment.t;\n\n            _context._axisProjections(pointer);\n            _context._labels.highlight(d, true);\n            var text = _context.model.time.formatDate(segment.t);\n            var selectedData = utils.find(_context.model.marker.select, function (f) {\n              return f[KEY] == d[KEY];\n            });\n            _context.model.marker.getFrame(pointer[TIMEDIM], function (values) {\n              var x = _context.xScale(values.axis_x[pointer[KEY]]);\n              var y = _context.yScale(values.axis_y[pointer[KEY]]);\n              var s = utils.areaToRadius(_context.sScale(values.size[pointer[KEY]]));\n              var c = values.color[pointer[KEY]] != null ? _context.cScale(values.color[pointer[KEY]]) : _context.COLOR_WHITEISH;\n              if (text !== selectedData.trailStartTime) {\n                _context._setTooltip(text, x, y, s + 3, c);\n              }\n              _context._setBubbleCrown(x, y, s, c);\n              _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", {\n                \"size\": values.size[pointer[KEY]],\n                \"color\": values.color[pointer[KEY]]\n              });\n            });\n            //change opacity to OPACITY_HIGHLT = 1.0;\n            d3.select(this).style(\"opacity\", 1.0);\n          }).on(\"mouseout\", function (segment, index) {\n            if (utils.isTouchDevice()) return;\n            _context._axisProjections();\n            _context._setTooltip();\n            _context._setBubbleCrown();\n            _context._labels.highlight(null, false);\n            _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", null);\n            d3.select(this).style(\"opacity\", _context.model.marker.opacityRegular);\n          }).each(function (segment, index) {\n            var view = d3.select(this);\n            view.append(\"circle\");\n            view.append(\"line\");\n          }).merge(entityTrails);\n          resolve();\n        }));\n      });\n      if (promises.length > 0) {\n        Promise.all(promises).then(function (segments) {\n          resolve(true);\n        });\n      } else {\n        resolve(true);\n      }\n    });\n    return this._isCreated;\n  },\n\n\n  /**\n   * add actions for each selected entities\n   * @param selections\n   * @param actions\n   * @private\n   */\n  _addActions: function _addActions(selections, actions) {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n\n    selections.forEach(function (d) {\n      if (!_this.actionsQueue[d[KEY]]) _this.actionsQueue[d[KEY]] = [];\n      _this.actionsQueue[d[KEY]] = [].concat(_this.actionsQueue[d[KEY]].filter(function (value) {\n        return actions.indexOf(value) == -1;\n      }), actions);\n    });\n  },\n  _clearActions: function _clearActions(selections) {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n\n    selections.forEach(function (d) {\n      if (!_this.actionsQueue[d[KEY]]) _this.actionsQueue[d[KEY]] = [];\n      _this.actionsQueue[d[KEY]] = [];\n      _this.drawingQueue[d[KEY]] = {};\n      _this.delayedIterations[d[KEY]] = {};\n      if (!_this.activePromises[d[KEY]]) _this.activePromises[d[KEY]] = [];\n      utils.forEach(_this.activePromises[d[KEY]], function (promise, key) {\n        if (promise.status === \"pending\") promise.reject();\n      });\n      _this.trailsInProgress[d[KEY]] = null;\n      _this.activePromises[d[KEY]] = [];\n    });\n  },\n  _getNextAction: function _getNextAction(key) {\n    return this.actionsQueue[key].shift();\n  },\n  run: function run(actions, selection, duration) {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n    if (!this._isCreated || _context.model.time.splash) return;\n    if (typeof actions === \"string\") actions = [actions];\n\n    this._isCreated.then(function () {\n      //quit if function is called accidentally\n      if ((!_context.model.ui.chart.trails || !_context.model.marker.select.length) && actions != \"remove\") return;\n\n      if (!duration) duration = 0;\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      selection = selection == null ? _context.model.marker.select : [selection];\n      for (var i = 0; i < actions.length; i++) {\n        if ([\"resize\", \"recolor\", \"remove\"].indexOf(actions[i]) != -1) {\n          (function () {\n            var action = actions.splice(i, 1).pop();\n            --i;\n            _this.trailsData.forEach(function (d) {\n              var trail = _this.entityTrails[d[KEY]];\n              _context._trails[\"_\" + action](trail, duration, d);\n            });\n          })();\n        }\n      }\n      if (actions.length == 0) {\n        return;\n      }\n      _this._addActions(selection, actions);\n      _this.trailsData.forEach(function (d) {\n        if (actions.indexOf(\"findVisible\") != -1) {\n          _this.drawingQueue[d[KEY]] = {};\n          _this.delayedIterations[d[KEY]] = {};\n        }\n        var trail = _this.entityTrails[d[KEY]];\n        //do all the actions over \"trail\"\n        var executeSequential = function executeSequential(index) {\n          // some function can be async, but we should run next when previous completed\n          var action = _this._getNextAction(d[KEY]);\n          if (action) {\n            _this.trailsInProgress[d[KEY]] = action;\n            var response = _context._trails[\"_\" + action](trail, duration, d);\n            if (response && response instanceof Promise) {\n              response.then(function () {\n                _this.trailsInProgress[d[KEY]] = null;\n                executeSequential(index + 1);\n              }, function () {\n                _this.trailsInProgress[d[KEY]] = null;\n              });\n            } else {\n              _this.trailsInProgress[d[KEY]] = null;\n              executeSequential(index + 1);\n            }\n          }\n        };\n        if (!_this.trailsInProgress[d[KEY]]) {\n          executeSequential(0);\n        }\n      });\n    });\n  },\n  _remove: function _remove(trail, duration, d) {\n    this.actionsQueue[d[this.context.KEY]] = [];\n    if (trail) {\n      // TODO: in some reason run twice\n      d3.select(this.entityTrails[d[this.context.KEY]].node().parentNode).remove();\n      this.entityTrails[d[this.context.KEY]] = null;\n    }\n  },\n  _resize: function _resize(trail, duration, d) {\n    var _context = this.context;\n    if (_context.model.time.splash) {\n      return;\n    }\n    //    this._isCreated.then(function() {\n    var updateLabel = false;\n\n    trail.each(function (segment, index) {\n\n      if (segment.valueY == null || segment.valueX == null || segment.valueS == null) return;\n\n      var view = d3.select(this);\n      if (duration) {\n        view.select(\"circle\").transition().duration(duration).ease(d3.easeLinear).attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"circle\").interrupt().attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS))).transition();\n      }\n\n      if (!updateLabel && !segment.transparent) {\n        updateLabel = true;\n        _context._labels.updateLabelOnlyPosition(d, null, { \"scaledS0\": utils.areaToRadius(_context.sScale(segment.valueS)) });\n      }\n\n      if (!segment.next) return;\n      var next = segment.next;\n      if (next == null) return;\n      if (next.valueY == null || next.valueX == null) return;\n\n      var lineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(next.valueX), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(next.valueY), 2));\n      if (duration) {\n        view.select(\"line\").transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(next.valueX)).attr(\"y1\", _context.yScale(next.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"stroke-dasharray\", lineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"line\").interrupt().attr(\"x1\", _context.xScale(next.valueX)).attr(\"y1\", _context.yScale(next.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"stroke-dasharray\", lineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS))).transition();\n      }\n    });\n  },\n  _recolor: function _recolor(trail, duration, d) {\n    var _context = this.context;\n\n    trail.each(function (segment, index) {\n\n      var view = d3.select(this);\n\n      var strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n      //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n      _context.model.marker.color.getColorShade({\n        colorID: segment.valueC,\n        shadeID: \"shade\"\n      }) :\n      //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n      segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;\n\n      view.select(\"circle\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n      .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n      view.select(\"line\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n      .style(\"stroke\", strokeColor);\n    });\n  },\n  _opacityHandler: function _opacityHandler(trail, duration, d) {\n    var _context = this.context;\n\n    trail.each(function (segment, index) {\n\n      var view = d3.select(this);\n\n      view\n      //.transition().duration(duration).ease(d3.easeLinear)\n      .style(\"opacity\", d.opacity || _context.model.marker.opacityRegular);\n    });\n  },\n  _findVisible: function _findVisible(trail, duration, d) {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n    return new Promise(function (resolve, reject) {\n      new Promise(function (resolve1, reject1) {\n        if (!d.limits) {\n          _context.model.marker.getEntityLimits(d[KEY]).then(function (limits) {\n            d.limits = limits;\n            resolve1();\n          });\n        } else {\n          resolve1();\n        }\n      }).then(function () {\n        if (!d.selectedEntityData.trailStartTime) {\n          d.selectedEntityData.trailStartTime = _context.model.time.formatDate(_context.time);\n        }\n        var trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n        if (_context.time - trailStartTime < 0 || d.limits.min - trailStartTime > 0) {\n          if (_context.time - trailStartTime < 0) {\n            // move trail start time with trail label back if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d3.max([_context.time, d.limits.min]));\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          } else {\n            // move trail start time with trail label to start time if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d.limits.min);\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          }\n          var cache = _context._labels.cached[d[KEY]];\n          var valueS = _context.frame.size[d[KEY]];\n          var valueC = _context.frame.color[d[KEY]];\n          cache.labelX0 = _context.frame.axis_x[d[KEY]];\n          cache.labelY0 = _context.frame.axis_y[d[KEY]];\n          cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_context.sScale(valueS)) : null;\n          cache.scaledC0 = valueC != null ? _context.cScale(valueC) : _context.COLOR_WHITEISH;\n          _context._updateLabel(d, 0, _context.frame.axis_x[d[KEY]], _context.frame.axis_y[d[KEY]], _context.frame.size[d[KEY]], _context.frame.color[d[KEY]], _context.frame.label[d[KEY]], _context.frame.size_label[d[KEY]], 0, true);\n        }\n        trail.each(function (segment, index) {\n          // segment is transparent if it is after current time or before trail StartTime\n          var segmentVisibility = segment.transparent;\n          segment.transparent = d.selectedEntityData.trailStartTime == null || segment.t - _context.time > 0 || trailStartTime - segment.t > 0\n          //no trail segment should be visible if leading bubble is shifted backwards, beyond start time\n          || d.selectedEntityData.trailStartTime - _context.model.time.formatDate(_context.time) >= 0;\n          // always update nearest 2 points\n          if (segmentVisibility != segment.transparent || Math.abs(_context.model.time.formatDate(segment.t) - _context.model.time.formatDate(_context.time)) < 2) segment.visibilityChanged = true; // segment changed, so need to update it\n          if (segment.transparent) {\n            d3.select(trail._groups[0][index]).classed(\"vzb-invisible\", segment.transparent);\n          }\n        });\n        _this.drawingQueue[d[KEY]] = {};\n        _this.delayedIterations[d[KEY]] = {};\n        resolve();\n      });\n    });\n  },\n  _abortAnimation: function _abortAnimation() {\n    var _context = this.context;\n    var _this = this;\n    var KEY = _context.KEY;\n    _this.trailsData.forEach(function (d) {\n      if (_this.trailTransitions[d[KEY]]) {\n        _this.trailTransitions[d[KEY]].select(\"line\").interrupt().transition();\n      }\n    });\n  },\n  _reveal: function _reveal(trail, duration, d) {\n    var _context = this.context;\n    if (_context.model.time.playing) duration = _context.model.time.delay;\n    var _this = this;\n    var KEY = _context.KEY;\n    d.status = \"reveal\";\n    var trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n    var generateTrailSegment = function generateTrailSegment(trail, index, nextIndex, level) {\n      return new Promise(function (resolve, reject) {\n        var view = d3.select(trail._groups[0][index]);\n\n        var segment = view.datum();\n\n        //console.log(d[KEY] + \" transparent: \" + segment.transparent + \" vis_changed:\" + segment.visibilityChanged);\n        if (nextIndex - index == 1) {\n          if (segment.transparent) {\n            view.classed(\"vzb-invisible\", segment.transparent);\n            return resolve();\n          } else if (!segment.visibilityChanged) {\n            // pass segment if it is not changed\n            return resolve();\n          }\n        }\n        _context.model.marker.getFrame(segment.t, function (frame) {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame) return resolve();\n          segment.valueY = frame.axis_y[d[KEY]];\n          segment.valueX = frame.axis_x[d[KEY]];\n          segment.valueS = frame.size[d[KEY]];\n          segment.valueC = frame.color[d[KEY]];\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            return resolve();\n          }\n\n          // fix label position if it not in correct place\n          if (trailStartTime && trailStartTime.toString() == segment.t.toString()) {\n            var cache = _context._labels.cached[d[KEY]];\n            cache.labelX0 = segment.valueX;\n            cache.labelY0 = segment.valueY;\n            var valueS = segment.valueS;\n            cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_context.sScale(valueS)) : null;\n            cache.scaledC0 = segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH;\n            _context._updateLabel(d, index, segment.valueX, segment.valueY, segment.valueS, segment.valueC, frame.label[d[KEY]], frame.size_label[d[KEY]], 0, true);\n          }\n          view.select(\"circle\")\n          //.transition().duration(duration).ease(d3.easeLinear)\n          .attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n          view.select(\"line\").attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"x1\", _context.xScale(segment.valueX)).attr(\"y1\", _context.yScale(segment.valueY));\n\n          // last point should have data for line but it is invisible\n          if (_context.time - segment.t > 0) {\n            segment.visibilityChanged = false;\n            view.classed(\"vzb-invisible\", segment.transparent);\n          } else {\n            view.classed(\"vzb-invisible\", true);\n          }\n\n          if (!trail._groups[0][nextIndex] || _context.time.toString() == segment.t.toString()) {\n            return resolve();\n          }\n\n          var next = d3.select(trail._groups[0][nextIndex]);\n          var nextSegment = next.datum();\n          nextSegment.previous = segment;\n          segment.next = nextSegment;\n          var nextTime = nextSegment.t;\n          if (_context.time - nextSegment.t < 0) {\n            // time is not equal start of year\n            segment.visibilityChanged = true; // redraw needed next time because line not have full length\n            nextTime = _context.time;\n          }\n          _context.model.marker.getFrame(nextTime, function (nextFrame) {\n            if (d.status != \"reveal\") return resolve();\n            if (!nextFrame || segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n              return resolve();\n            }\n\n            if (nextFrame.axis_x[d[KEY]] == null || nextFrame.axis_y[d[KEY]] == null) {\n              return resolve();\n            }\n\n            nextSegment.valueY = nextFrame.axis_y[d[KEY]];\n            nextSegment.valueX = nextFrame.axis_x[d[KEY]];\n            nextSegment.valueS = nextFrame.size[d[KEY]];\n            nextSegment.valueC = nextFrame.color[d[KEY]];\n\n            _this.trailTransitions[d[KEY]] = view;\n            var strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n            //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n            _context.model.marker.color.getColorShade({\n              colorID: segment.valueC,\n              shadeID: \"shade\"\n            }) :\n            //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n            segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;\n\n            var lineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextFrame.axis_x[d[KEY]]), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextFrame.axis_y[d[KEY]]), 2));\n            view.select(\"line\").attr(\"stroke-dasharray\", lineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"stroke\", strokeColor).transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(nextSegment.valueX)).attr(\"y1\", _context.yScale(nextSegment.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY));\n            if (nextIndex - index > 1) {\n              addNewIntervals(index, nextIndex);\n              return resolve();\n            }\n            return resolve();\n          });\n        });\n      });\n    };\n    var addPointBetween = function addPointBetween(previousIndex, nextIndex, index) {\n      return new Promise(function (resolve, reject) {\n        var previous = d3.select(trail._groups[0][previousIndex]);\n        var next = d3.select(trail._groups[0][nextIndex]);\n        var view = d3.select(trail._groups[0][index]);\n        var previousSegment = previous.datum();\n        var nextSegment = next.datum();\n        var segment = view.datum();\n\n        if (!previousSegment.previous && !previousSegment.next || !nextSegment.previous && !nextSegment.next) {\n          // segment data cleared by create action\n          return resolve();\n        }\n\n        _context.model.marker.getFrame(segment.t, function (frame) {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame || typeof frame.axis_x === \"undefined\" || frame.axis_x[d[KEY]] == null || typeof frame.axis_y === \"undefined\" || frame.axis_y[d[KEY]] == null) {\n            utils.warn(\"Frame for trail missed: \" + segment.t);\n            return resolve();\n          }\n          segment.valueY = frame.axis_y[d[KEY]];\n          segment.valueX = frame.axis_x[d[KEY]];\n          segment.valueS = frame.size[d[KEY]];\n          segment.valueC = frame.color[d[KEY]];\n\n          segment.previous = previousSegment;\n          segment.next = nextSegment;\n          previousSegment.next = segment;\n          nextSegment.previous = segment;\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            utils.warn(\"Data for trail point missed: \" + segment.t);\n            return resolve();\n          }\n\n          var strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n          //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n          _context.model.marker.color.getColorShade({\n            colorID: segment.valueC,\n            shadeID: \"shade\"\n          }) :\n          //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n          segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;\n\n          var firstLineLength = Math.sqrt(Math.pow(_context.xScale(previousSegment.valueX) - _context.xScale(segment.valueX), 2) + Math.pow(_context.yScale(previousSegment.valueY) - _context.yScale(segment.valueX), 2));\n\n          previous.select(\"line\").transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(segment.valueX)).attr(\"y1\", _context.yScale(segment.valueY)).attr(\"x2\", _context.xScale(previousSegment.valueX)).attr(\"y2\", _context.yScale(previousSegment.valueY)).attr(\"stroke-dasharray\", firstLineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(previousSegment.valueS))).style(\"stroke\", strokeColor);\n\n          view.classed(\"vzb-invisible\", segment.transparent);\n\n          if (!segment.transparent) {\n            view.select(\"circle\")\n            //.transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"cy\", _context.yScale(segment.valueY)).attr(\"cx\", _context.xScale(segment.valueX)).attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n            var secondLineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextSegment.valueX), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextSegment.valueY), 2));\n\n            view.select(\"line\").transition().duration(duration).ease(d3.easeLinear).attr(\"x1\", _context.xScale(nextSegment.valueX)).attr(\"y1\", _context.yScale(nextSegment.valueY)).attr(\"x2\", _context.xScale(segment.valueX)).attr(\"y2\", _context.yScale(segment.valueY)).attr(\"stroke-dasharray\", secondLineLength).attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS))).style(\"stroke\", strokeColor);\n          }\n          addNewIntervals(previousIndex, index, nextIndex);\n          resolve();\n        });\n      });\n    };\n    var addNewIntervals = function addNewIntervals(previousIndex, index, nextIndex) {\n      var mediumIndex = void 0;\n      if (index - previousIndex > 1) {\n        mediumIndex = getPointBetween(previousIndex, index);\n        _this.delayedIterations[d[KEY]][previousIndex] = {\n          first: previousIndex,\n          next: index,\n          medium: mediumIndex\n        };\n      }\n      if (nextIndex && nextIndex - index > 1) {\n        mediumIndex = getPointBetween(index, nextIndex);\n        _this.delayedIterations[d[KEY]][index] = {\n          first: index,\n          next: nextIndex,\n          medium: mediumIndex\n        };\n      }\n    };\n    var getPointBetween = function getPointBetween(previous, next) {\n      return Math.round(previous + (next - previous) / 2);\n    };\n\n    var _generateKeys = function _generateKeys(d, trail, div) {\n      var response = [];\n      var min = 0,\n          max = 0;\n      var maxValue = d3.min([d.limits.max, _context.time]);\n      var minValue = d3.max([d.limits.min, _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime)]);\n      utils.forEach(trail._groups[0], function (segment, index) {\n        var data = segment.__data__;\n        if (data.t - minValue == 0) {\n          min = index;\n        } else if (data.t - maxValue == 0) {\n          max = index;\n        } else {\n          if (data.t > minValue && data.t < maxValue) {\n            if (_context.model.time.formatDate(data.t) % div == 0 || data.next && data.previous) {\n              response.push(index);\n            }\n          }\n        }\n      });\n      response.unshift(min);\n      if (max > 0) {\n        response.push(max);\n      }\n      return response;\n    };\n\n    var processPoints = function processPoints() {\n      return new Promise(function (resolve, reject) {\n        var processPoint = function processPoint() {\n          var pointIndex = Object.keys(_this.drawingQueue[d[KEY]])[Math.floor(Math.random() * Object.keys(_this.drawingQueue[d[KEY]]).length)];\n          var point = JSON.parse(JSON.stringify(_this.drawingQueue[d[KEY]][pointIndex]));\n          delete _this.drawingQueue[d[KEY]][pointIndex];\n          addPointBetween(point.first, point.next, point.medium).then(function () {\n            if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n              processPoint();\n            } else {\n              resolve();\n            }\n          });\n        };\n        if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n          processPoint(_this.drawingQueue[d[KEY]]);\n        } else {\n          resolve();\n        }\n      });\n    };\n\n    return new Promise(function (resolve, reject) {\n      /**\n       * iteration for each point from first segment to last\n       * @param trail\n       * @param index\n       */\n      var generateTrails = function generateTrails(trail, index) {\n        if (index < 0 || index >= trail._groups[0].length) {\n          return resolve();\n        }\n        generateTrailSegment(trail, index, index + 1).then(function () {\n          generateTrails(trail, index + 1);\n        }, function () {\n          return resolve();\n        });\n      };\n\n      /**\n       * recursive iteration for drawing point between points calculated in previous step\n       */\n      var processPointsBetween = function processPointsBetween() {\n        processPoints().then(function () {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            return resolve();\n          }\n          _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n          _this.delayedIterations[d[KEY]] = {};\n          processPointsBetween();\n        }, function () {\n          return resolve();\n        });\n      };\n\n      if (_context.model.marker.framesAreReady()) {\n        generateTrails(trail, 0);\n      } else {\n        _this.delayedIterations[d[KEY]] = {};\n        _this.drawingQueue[d[KEY]] = {};\n        var trailKeys = _generateKeys(d, trail, 50);\n        var segments = [];\n        if (trailKeys.length <= 1) {\n          return resolve();\n        }\n\n        _this.delayedIterations[d[KEY]] = {};\n        for (var i = 0; i < trailKeys.length - 1; i++) {\n          segments.push(generateTrailSegment(trail, trailKeys[i], trailKeys[i + 1], 1));\n        }\n        Promise.all(segments).then(function () {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            resolve();\n          } else {\n            _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n            _this.delayedIterations[d[KEY]] = {};\n            processPointsBetween();\n          }\n        }, function () {\n          resolve();\n        });\n      }\n    });\n  }\n});\n\nexports.default = Trail;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n;(function(root, factory) {\n\t// https://github.com/umdjs/umd/blob/master/returnExports.js\n\tif (true) {\n\t\t// For Node.js.\n\t\tmodule.exports = factory(root);\n\t} else if (typeof define == 'function' && define.amd) {\n\t\t// For AMD. Register as an anonymous module.\n\t\tdefine([], factory.bind(root, root));\n\t} else {\n\t\t// For browser globals (not exposing the function separately).\n\t\tfactory(root);\n\t}\n}(typeof global != 'undefined' ? global : this, function(root) {\n\n\tif (root.CSS && root.CSS.escape) {\n\t\treturn root.CSS.escape;\n\t}\n\n\t// https://drafts.csswg.org/cssom/#serialize-an-identifier\n\tvar cssEscape = function(value) {\n\t\tif (arguments.length == 0) {\n\t\t\tthrow new TypeError('`CSS.escape` requires an argument.');\n\t\t}\n\t\tvar string = String(value);\n\t\tvar length = string.length;\n\t\tvar index = -1;\n\t\tvar codeUnit;\n\t\tvar result = '';\n\t\tvar firstCodeUnit = string.charCodeAt(0);\n\t\twhile (++index < length) {\n\t\t\tcodeUnit = string.charCodeAt(index);\n\t\t\t// Note: theres no need to special-case astral symbols, surrogate\n\t\t\t// pairs, or lone surrogates.\n\n\t\t\t// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER\n\t\t\t// (U+FFFD).\n\t\t\tif (codeUnit == 0x0000) {\n\t\t\t\tresult += '\\uFFFD';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n\t\t\t\t// U+007F, []\n\t\t\t\t(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||\n\t\t\t\t// If the character is the first character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039), []\n\t\t\t\t(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||\n\t\t\t\t// If the character is the second character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039) and the first character is a `-` (U+002D), []\n\t\t\t\t(\n\t\t\t\t\tindex == 1 &&\n\t\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 &&\n\t\t\t\t\tfirstCodeUnit == 0x002D\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n\t\t\t\tresult += '\\\\' + codeUnit.toString(16) + ' ';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is the first character and is a `-` (U+002D), and\n\t\t\t\t// there is no second character, []\n\t\t\t\tindex == 0 &&\n\t\t\t\tlength == 1 &&\n\t\t\t\tcodeUnit == 0x002D\n\t\t\t) {\n\t\t\t\tresult += '\\\\' + string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the character is not handled by one of the above rules and is\n\t\t\t// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or\n\t\t\t// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to\n\t\t\t// U+005A), or [a-z] (U+0061 to U+007A), []\n\t\t\tif (\n\t\t\t\tcodeUnit >= 0x0080 ||\n\t\t\t\tcodeUnit == 0x002D ||\n\t\t\t\tcodeUnit == 0x005F ||\n\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 ||\n\t\t\t\tcodeUnit >= 0x0041 && codeUnit <= 0x005A ||\n\t\t\t\tcodeUnit >= 0x0061 && codeUnit <= 0x007A\n\t\t\t) {\n\t\t\t\t// the character itself\n\t\t\t\tresult += string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Otherwise, the escaped character.\n\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character\n\t\t\tresult += '\\\\' + string.charAt(index);\n\n\t\t}\n\t\treturn result;\n\t};\n\n\tif (!root.CSS) {\n\t\troot.CSS = {};\n\t}\n\n\troot.CSS.escape = cssEscape;\n\treturn cssEscape;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"<!-- Bubble Chart Component -->\\n<div class=\\\"vzb-bubblechart\\\">\\n    <svg class=\\\"vzb-bubblechart-svg vzb-export\\\">\\n        <g class=\\\"vzb-bc-graph\\\">\\n            <g class=\\\"vzb-bc-year\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-axis-x\\\"><g></g></svg>\\n            <svg class=\\\"vzb-bc-axis-y\\\"><g></g></svg>\\n            <line class=\\\"vzb-bc-projection-x\\\"></line>\\n            <line class=\\\"vzb-bc-projection-y\\\"></line>\\n\\n            <svg class=\\\"vzb-bc-bubbles-crop\\\">\\n                <g class=\\\"vzb-zoom-selection\\\"></g>\\n                <line class=\\\"vzb-bc-line-equal-xy vzb-invisible\\\"></line>\\n                <rect class=\\\"vzb-bc-eventarea\\\"></rect>\\n                <g class=\\\"vzb-bc-trails\\\"></g>\\n                <g class=\\\"vzb-bc-bubbles\\\"></g>\\n                <g class=\\\"vzb-bc-lines\\\"></g>\\n                <g class=\\\"vzb-bc-bubble-crown vzb-hidden\\\">\\n                    <circle class=\\\"vzb-crown-glow\\\"></circle>\\n                    <circle class=\\\"vzb-crown\\\"></circle>\\n                </g>\\n            </svg>\\n\\n            <g class=\\\"vzb-bc-axis-y-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-s-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-c-title\\\"></g>\\n\\n            <g class=\\\"vzb-bc-axis-y-info vzb-noexport\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-info vzb-noexport\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-labels-crop\\\">\\n                <g class=\\\"vzb-bc-labels\\\"></g>\\n            </svg>\\n\\n            <g class=\\\"vzb-data-warning vzb-noexport\\\">\\n                <svg></svg>\\n                <text></text>\\n            </g>\\n\\n            <rect class=\\\"vzb-bc-zoom-rect\\\"></rect>\\n            <g class=\\\"vzb-bc-tooltip vzb-hidden\\\">\\n                <rect class=\\\"vzb-tooltip-glow\\\"></rect>\\n                <rect class=\\\"vzb-tooltip-border\\\"></rect>\\n                <text class=\\\"vzb-tooltip-text\\\"></text>\\n            </g>\\n        </g>\\n    </svg>\\n    <svg>\\n        <defs>\\n            <filter id=\\\"vzb-glow-filter\\\" x=\\\"-50%\\\" y=\\\"-50%\\\" width=\\\"200%\\\" height=\\\"200%\\\">\\n                <feGaussianBlur in=\\\"SourceGraphic\\\" stdDeviation=\\\"2\\\"></feGaussianBlur>\\n            </filter>\\n        </defs>\\n    </svg>\\n    <!-- This could possibly be another component -->\\n    <div class=\\\"vzb-tooltip vzb-hidden vzb-tooltip-mobile\\\"></div>\\n</div>\\n\";\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bubblechart.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 39c4092c7be8eac754a0","import \"./styles.scss\";\nimport component from \"./component\";\n\nconst VERSION_INFO = { version: __VERSION, build: __BUILD };\n\nexport default Vizabi.Tool.extend(\"BubbleChart\", {\n\n  /**\n   * Initializes the tool (Bubble Chart Tool).\n   * Executed once before any template is rendered.\n   * @param {Object} placeholder Placeholder element for the tool\n   * @param {Object} external_model Model as given by the external page\n   */\n  init(placeholder, external_model) {\n\n    this.name = \"bubblechart\";\n\n    //specifying components\n    this.components = [{\n      component,\n      placeholder: \".vzb-tool-viz\",\n      model: [\"state.time\", \"state.entities\", \"state.marker\", \"locale\", \"ui\"] //pass models to component\n    }, {\n      component: Vizabi.Component.get(\"timeslider\"),\n      placeholder: \".vzb-tool-timeslider\",\n      model: [\"state.time\", \"state.entities\", \"state.marker\", \"ui\"]\n    }, {\n      component: Vizabi.Component.get(\"dialogs\"),\n      placeholder: \".vzb-tool-dialogs\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"buttonlist\"),\n      placeholder: \".vzb-tool-buttonlist\",\n      model: [\"state\", \"ui\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"treemenu\"),\n      placeholder: \".vzb-tool-treemenu\",\n      model: [\"state.marker\", \"state.marker_tags\", \"state.time\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datawarning\"),\n      placeholder: \".vzb-tool-datawarning\",\n      model: [\"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"datanotes\"),\n      placeholder: \".vzb-tool-datanotes\",\n      model: [\"state.marker\", \"locale\"]\n    }, {\n      component: Vizabi.Component.get(\"steppedspeedslider\"),\n      placeholder: \".vzb-tool-stepped-speed-slider\",\n      model: [\"state.time\", \"locale\"]\n    }];\n\n    this._super(placeholder, external_model);\n\n  },\n\n  validate(model) {\n    model = this.model || model;\n\n    this._super(model);\n\n    if (model.ui.chart.lockNonSelected) {\n      const time = model.state.time.parse(\"\" + model.ui.chart.lockNonSelected);\n      if (time < model.state.time.start) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.start);\n      if (time > model.state.time.end) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.end);\n    }\n  },\n\n  /**\n   * Determines the default model of this tool\n   */\n  default_model: {\n    state: {\n      time: {\n        autogenerate: {\n          data: \"data\",\n          conceptIndex: 0,\n          conceptType: \"time\"\n        }\n      },\n      entities: {\n        autogenerate: {\n          data: \"data\",\n          conceptIndex: 0\n        }\n      },\n      entities_colorlegend: {\n        autogenerate: {\n          data: \"data\",\n          conceptIndex: 0\n        }\n      },\n      entities_tags: {},\n      marker_tags: {\n        space: [\"entities_tags\"],\n        label: {},\n        hook_parent: {}\n      },\n      marker: {\n        space: [\"entities\", \"time\"],\n        axis_x: {\n          use: \"indicator\",\n          autogenerate: {\n            conceptIndex: 1,\n            conceptType: \"measure\"\n          }\n        },\n        axis_y: {\n          use: \"indicator\",\n          autogenerate: {\n            conceptIndex: 0,\n            conceptType: \"measure\"\n          }\n        },\n        label: {\n          use: \"property\",\n          autogenerate: {\n            conceptIndex: 0\n          }\n        },\n        size: {\n          autogenerate: {\n            conceptIndex: 2,\n            conceptType: \"measure\"\n          }\n        },\n        color: {\n          syncModels: [\"marker_colorlegend\"],\n          autogenerate: {\n            conceptIndex: 0,\n            conceptType: \"entity_set\"\n          }\n        },\n        size_label: {\n          use: \"constant\",\n          which: \"_default\",\n          scaleType: \"ordinal\",\n          _important: false,\n          extent: [0, 0.33],\n          allow: {\n            names: [\"_default\"]\n          }\n        },\n      },\n      \"marker_colorlegend\": {\n        \"space\": [\"entities_colorlegend\"],\n        \"label\": {\n          \"use\": \"property\",\n          \"which\": \"name\"\n        },\n        \"hook_rank\": {\n          \"use\": \"property\",\n          \"which\": \"rank\"\n        },\n        \"hook_geoshape\": {\n          \"use\": \"property\",\n          \"which\": \"shape_lores_svg\"\n        }\n      }\n    },\n    locale: {},\n    ui: {\n      chart: {\n        whenHovering: {\n          showProjectionLineX: true,\n          showProjectionLineY: true,\n          higlightValueX: true,\n          higlightValueY: true\n        },\n        labels: {\n          dragging: true,\n          removeLabelBox: false\n        },\n        trails: true,\n        lockNonSelected: 0\n      },\n      datawarning: {\n        doubtDomain: [],\n        doubtRange: []\n      },\n      presentation: false,\n      panWithArrow: false,\n      adaptMinMaxZoom: false,\n      cursorMode: \"arrow\",\n      zoomOnScrolling: false,\n      buttons: [\"colors\", \"find\", \"trails\", \"lock\", \"moreoptions\", \"fullscreen\", \"presentation\"],\n      dialogs: {\n        popup: [\"colors\", \"find\", \"size\", \"zoom\", \"moreoptions\"],\n        sidebar: [\"colors\", \"find\", \"size\", \"zoom\"],\n        moreoptions: [\"opacity\", \"speed\", \"axes\", \"size\", \"colors\", \"label\", \"zoom\", \"presentation\", \"about\"]\n      }\n    }\n  },\n\n  versionInfo: VERSION_INFO\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","const { utils } = Vizabi;\n\nconst {\n  svgexport: Exporter,\n  labels: Labels,\n  'd3.axisWithLabelPicker': axisSmart,\n  'd3.dynamicBackground': DynamicBackground\n} = Vizabi.helpers;\n\nconst {\n  warn: iconWarn,\n  question: iconQuestion\n} = Vizabi.iconset;\n\nimport Trail from './trail';\nimport PanZoom from './panzoom';\n\n\n// BUBBLE CHART COMPONENT\nconst BubbleChart = Vizabi.Component.extend(\"bubblechart\", {\n\n  /**\n   * Initializes the component (Bubble Chart).\n   * Executed once before any template is rendered.\n   * @param {Object} config The config passed to the component\n   * @param {Object} context The component's parent\n   */\n  init(config, context) {\n    const _this = this;\n    this.name = \"bubblechart\";\n    this.template = require(\"./template.html\");\n\n    //define expected models for this component\n    this.model_expects = [{\n      name: \"time\",\n      type: \"time\"\n    }, {\n      name: \"entities\",\n      type: \"entities\"\n    }, {\n      name: \"marker\",\n      type: \"model\"\n    }, {\n      name: \"locale\",\n      type: \"locale\"\n    }, {\n      name: \"ui\",\n      type: \"ui\"\n    }];\n\n    this.model_binds = {\n      \"change:time.playing\": function(evt, original) {\n        if (utils.isTouchDevice() && _this.model.time.playing && _this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n      },\n      \"change:time.start\": function(evt, original) {\n        if (_this.model.marker.color.scaleType === \"time\") {\n          _this.model.marker.color.scale = null;\n        }\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        _this._trails.create().then(() => {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.end\": function(evt, original) {\n        if (!_this._readyOnce || _this.model.time.splash) return;\n        _this._trails.create().then(() => {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n      },\n      \"change:time.record\": function() {\n        //console.log(\"change time record\");\n        if (_this.model.time.record) {\n          _this._export.open(this.element, this.name);\n        } else {\n          _this._export.reset();\n        }\n      },\n      \"change:ui.chart.trails\": function(evt) {\n        //console.log(\"EVENT change:time:trails\");\n        _this._trails.toggle(_this.model.ui.chart.trails);\n        _this.redrawDataPoints();\n      },\n      \"change:ui.chart.lockNonSelected\": function(evt) {\n        //console.log(\"EVENT change:time:lockNonSelected\");\n        _this.redrawDataPoints(500);\n      },\n      \"change:marker\": function(evt, path) {\n        // bubble size change is processed separately\n        if (!_this._readyOnce) return;\n        if (path.indexOf(\"scaleType\") > -1) {\n          _this.ready();\n          return;\n        }\n\n        if (path.indexOf(\"marker.color\") !== -1) return;\n        if (path.indexOf(\"marker.size\") !== -1) return;\n        if (path.indexOf(\"marker.size_label\") !== -1) return;\n\n        if (path.indexOf(\"domainMin\") > -1 || path.indexOf(\"domainMax\") > -1) {\n          if (!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress\n          _this.updateSize();\n          _this.updateMarkerSizeLimits();\n          _this._trails.run(\"findVisible\");\n          _this.redrawDataPoints();\n          _this._trails.run(\"resize\", null, 500);\n        } else if (path.indexOf(\"zoomedMin\") > -1 || path.indexOf(\"zoomedMax\") > -1) {\n          if (_this.draggingNow) return;\n\n          //avoid zooming again if values didn't change.\n          //also prevents infinite loop on forced URL update from zoom.stop()\n          if (utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMin, _this.model.marker.axis_x.zoomedMin, 0.01)\n            && utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMax, _this.model.marker.axis_x.zoomedMax, 0.01)\n            && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMin, _this.model.marker.axis_y.zoomedMin, 0.01)\n            && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMax, _this.model.marker.axis_y.zoomedMax, 0.01)\n          ) return;\n          let playAfterZoom = false;\n          if (_this.model.time.playing) {\n            playAfterZoom = true;\n            _this.model.time.pause(true);\n          }\n          _this._trails.run(\"abortAnimation\");\n          _this._panZoom.zoomToMaxMin(\n            _this.model.marker.axis_x.getZoomedMin(),\n            _this.model.marker.axis_x.getZoomedMax(),\n            _this.model.marker.axis_y.getZoomedMin(),\n            _this.model.marker.axis_y.getZoomedMax(),\n            500 /*duration*/, \"don't feed these zoom values back to state\"\n          );\n          if (playAfterZoom) {\n            _this.model.time.postponePause = false;\n          }\n        }\n\n        //console.log(\"EVENT change:marker\", evt);\n      },\n      \"change:marker.select\": function(evt, path) {\n        if (!_this._readyOnce || !_this.entityBubbles) return;\n        //console.log(\"EVENT change:entities:select\");\n\n        //disable trails if too many items get selected at once\n        //otherwise it's too much waiting time\n        if ((evt.source._val || []).length - (evt.source._previousVal || []).length > 50) _this.model.ui.chart.trails = false;\n\n        _this.selectDataPoints();\n        _this.redrawDataPoints();\n        _this._trails.create().then(() => {\n          _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n        });\n        _this.updateBubbleOpacity();\n        _this._updateDoubtOpacity();\n      },\n      \"change:marker.highlight\": function(evt, path) {\n        if (!_this._readyOnce) return;\n        //path have values if trail is highlighted\n        if (path != \"highlight\") {\n          if (path !== null) {\n            const titles = _this._formatSTitleValues(path.size, path.color);\n            _this._updateSTitle(titles[0], titles[1]);\n          } else {\n            _this._updateSTitle();\n          }\n          return;\n        }\n        //console.log(\"EVENT change:entities:highlight\");\n        _this.highlightDataPoints();\n      },\n      \"change:time.value\": function() {\n        if (!_this._readyOnce || !_this.entityBubbles) return;\n        if (!_this.calculationQueue) { // collect timestamp that we request\n          _this.calculationQueue = [_this.model.time.value.toString()];\n        } else {\n          _this.calculationQueue.push(_this.model.time.value.toString());\n        }\n        (function(time) { // isolate timestamp\n          //_this._bubblesInteract().mouseout();\n          _this.model.marker.getFrame(time, (frame, time) => {\n            if (!_this._frameIsValid(frame)) return utils.warn(\"change:time.value: empty data received from marker.getFrame(). doing nothing\");\n            const index = _this.calculationQueue.indexOf(time.toString()); //\n            if (index == -1) { // we was receive more recent frame before so we pass this frame\n              return;\n            }\n            _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp\n            _this.frameChanged(frame, time);\n          });\n\n        })(_this.model.time.value);\n      },\n      \"change:ui.adaptMinMaxZoom\": function() {\n        //console.log(\"EVENT change:ui:adaptMinMaxZoom\");\n        if (_this.model.ui.adaptMinMaxZoom) {\n          _this._panZoom.expandCanvas(500);\n        } else {\n          _this._panZoom.reset();\n        }\n      },\n      \"change:marker.size.extent\": function(evt, path) {\n        //console.log(\"EVENT change:marker:size:max\");\n        if (!_this._readyOnce) return;\n        _this.updateMarkerSizeLimits();\n        _this.redrawDataPointsOnlySize();\n        _this._trails.run(\"resize\");\n      },\n      \"change:marker.color\": function(evt, path) {\n        if (!_this._readyOnce) return;\n        //console.log(\"EVENT change:marker:color:palette\");\n        _this.redrawDataPointsOnlyColors();\n        _this._trails.run(\"recolor\");\n      },\n      // 'change:marker.color.palette': function(evt, path) {\n      //   if(!_this._readyOnce) return;\n      //   //console.log(\"EVENT change:marker:color:palette\");\n      //   _this.redrawDataPointsOnlyColors();\n      //   _this._trails.run(\"recolor\");\n      // },\n      \"change:marker.opacitySelectDim\": function() {\n        _this.updateBubbleOpacity();\n      },\n      \"change:marker.opacityRegular\": function() {\n        _this.updateBubbleOpacity();\n        _this._trails.run(\"opacityHandler\");\n      },\n      \"change:ui.cursorMode\": function() {\n        const svg = _this.chartSvg;\n        if (_this.model.ui.cursorMode === \"plus\") {\n          svg.classed(\"vzb-zoomin\", true);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"minus\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", true);\n          svg.classed(\"vzb-panhand\", false);\n        } else if (_this.model.ui.cursorMode === \"hand\") {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", true);\n        } else {\n          svg.classed(\"vzb-zoomin\", false);\n          svg.classed(\"vzb-zoomout\", false);\n          svg.classed(\"vzb-panhand\", false);\n        }\n      },\n      \"change:entities.dim\": function() {\n        if (_this.someHighlighted) {\n          _this.model.marker.clearHighlighted();\n        }\n        if (_this.someSelected) {\n          _this.model.marker.clearSelected();\n        }\n      },\n      \"ready\": function() {\n        // if(_this.model.marker.color.scaleType === 'time') {\n        //   _this.model.marker.color.scale = null;\n        //   utils.defer(function() {\n        //     _this.trigger('ready');\n        //   });\n        // }\n      }\n    };\n\n    this._super(config, context);\n\n    this.xScale = null;\n    this.yScale = null;\n    this.sScale = null;\n    this.cScale = null;\n\n    this.xAxis = axisSmart(\"bottom\");\n    this.yAxis = axisSmart(\"left\");\n\n    _this.COLOR_BLACKISH = \"#333\";\n    _this.COLOR_WHITEISH = \"#fdfdfd\";\n\n    this.isCanvasPreviouslyExpanded = false;\n    this.draggingNow = null;\n\n    this._trails = new Trail(this);\n    this._panZoom = new PanZoom(this);\n    this._export = new Exporter(this);\n    this._export\n      .prefix(\"vzb-bc-\")\n      .deleteClasses([\"vzb-bc-bubbles-crop\", \"vzb-hidden\", \"vzb-bc-year\", \"vzb-bc-zoom-rect\",\n        \"vzb-bc-projection-x\", \"vzb-bc-projection-y\", \"vzb-bc-axis-c-title\"\n      ]);\n    this._labels = new Labels(this);\n    this._labels.config({\n      CSS_PREFIX: \"vzb-bc\",\n      LABELS_CONTAINER_CLASS: \"vzb-bc-labels\",\n      LINES_CONTAINER_CLASS: \"vzb-bc-bubbles\",\n      LINES_CONTAINER_SELECTOR_PREFIX: \"bubble-\"\n    });\n  },\n\n  _rangeBump(arg, undo) {\n    const bump = this.activeProfile.maxRadiusPx / 2;\n    undo = undo ? -1 : 1;\n    if (utils.isArray(arg) && arg.length > 1) {\n      let z1 = arg[0];\n      let z2 = arg[arg.length - 1];\n\n      //the sign of bump depends on the direction of the scale\n      if (z1 < z2) {\n        z1 += bump * undo;\n        z2 -= bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 > z2) z1 = z2 = (z1 + z2) / 2;\n      } else if (z1 > z2) {\n        z1 -= bump * undo;\n        z2 += bump * undo;\n        // if the scale gets inverted because of bump, set it to avg between z1 and z2\n        if (z1 < z2) z1 = z2 = (z1 + z2) / 2;\n      } else {\n        // rangeBump error: the input scale range has 0 length. that sucks but we keep cool\n      }\n      return [z1, z2];\n    }\n    utils.warn(\"rangeBump error: input is not an array or empty\");\n  },\n\n\n  /**\n   * Executes right after the template is in place, but the model is not yet ready\n   */\n  readyOnce() {\n    const _this = this;\n    this._readyOnce = false;\n    this.scrollableAncestor = utils.findScrollableAncestor(this.element);\n    this.element = d3.select(this.element);\n\n    // reference elements\n    this.chartSvg = this.element.select(\"svg\");\n    this.graph = this.element.select(\".vzb-bc-graph\");\n    this.yAxisElContainer = this.graph.select(\".vzb-bc-axis-y\");\n    this.yAxisEl = this.yAxisElContainer.select(\"g\");\n\n    this.xAxisElContainer = this.graph.select(\".vzb-bc-axis-x\");\n    this.xAxisEl = this.xAxisElContainer.select(\"g\");\n\n    this.yTitleEl = this.graph.select(\".vzb-bc-axis-y-title\");\n    this.xTitleEl = this.graph.select(\".vzb-bc-axis-x-title\");\n    this.sTitleEl = this.graph.select(\".vzb-bc-axis-s-title\");\n    this.cTitleEl = this.graph.select(\".vzb-bc-axis-c-title\");\n    this.yearEl = this.graph.select(\".vzb-bc-year\");\n\n    this.year = new DynamicBackground(this.yearEl);\n\n    this.yInfoEl = this.graph.select(\".vzb-bc-axis-y-info\");\n    this.xInfoEl = this.graph.select(\".vzb-bc-axis-x-info\");\n    this.dataWarningEl = this.graph.select(\".vzb-data-warning\");\n\n    this.projectionX = this.graph.select(\".vzb-bc-projection-x\");\n    this.projectionY = this.graph.select(\".vzb-bc-projection-y\");\n    this.lineEqualXY = this.graph.select(\".vzb-bc-line-equal-xy\");\n\n    this.trailsContainer = this.graph.select(\".vzb-bc-trails\");\n    this.bubbleContainerCrop = this.graph.select(\".vzb-bc-bubbles-crop\");\n    this.zoomSelection = this.graph.select(\".vzb-zoom-selection\");\n    this.labelsContainerCrop = this.graph.select(\".vzb-bc-labels-crop\");\n    this.bubbleContainer = this.graph.select(\".vzb-bc-bubbles\");\n    this.labelsContainer = this.graph.select(\".vzb-bc-labels\");\n    this.linesContainer = this.graph.select(\".vzb-bc-lines\");\n    this.zoomRect = this.element.select(\".vzb-bc-zoom-rect\");\n    this.eventArea = this.element.select(\".vzb-bc-eventarea\");\n\n    this.entityBubbles = null;\n    this.bubbleCrown = this.element.select(\".vzb-bc-bubble-crown\");\n    //set filter\n    this.bubbleCrown.selectAll(\".vzb-crown-glow\")\n      .attr(\"filter\", \"url(\" + location.pathname + \"#vzb-glow-filter)\");\n    this.tooltip = this.element.select(\".vzb-bc-tooltip\");\n    //set filter\n    this.tooltip.select(\".vzb-tooltip-glow\")\n      .attr(\"filter\", \"url(\" + location.pathname + \"#vzb-glow-filter)\");\n\n    this.tooltipMobile = this.element.select(\".vzb-tooltip-mobile\");\n    //component events\n    this.on(\"resize\", () => {\n      //console.log(\"EVENT: resize\");\n      //return if updatesize exists with error\n      _this._trails.run(\"abortAnimation\");\n      if (_this.updateSize()) return;\n      _this.updateMarkerSizeLimits();\n      _this._labels.updateSize();\n      (function(xMin, xMax, yMin, yMax) {\n        _this._panZoom.zoomer.dontFeedToState = true;\n        _this._panZoom.rerun(); // includes redraw data points and trail resize\n        _this._panZoom.zoomToMaxMin(xMin, xMax, yMin, yMax, 0, true);\n      })(_this._zoomedXYMinMax.axis_x.zoomedMin,\n        _this._zoomedXYMinMax.axis_x.zoomedMax,\n        _this._zoomedXYMinMax.axis_y.zoomedMin,\n        _this._zoomedXYMinMax.axis_y.zoomedMax);\n    });\n\n    //keyboard listeners\n    d3.select(\"body\")\n      .on(\"keydown\", () => {\n        if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n        if (d3.event.metaKey || d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", true);\n      })\n      .on(\"keyup\", () => {\n        if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n        if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n      })\n      //this is for the case when user would press ctrl and move away from the browser tab or window\n      //keyup event would happen somewhere else and won't be captured, so zoomin class would get stuck\n      .on(\"mouseenter\", () => {\n        if (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\") return;\n        if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select(\"svg\").classed(\"vzb-zoomin\", false);\n      });\n\n    this.root.on(\"resetZoom\", () => {\n      _this._panZoom.reset(null, 500);\n    });\n\n    this._panZoom.zoomSelection(this.bubbleContainerCrop);\n    this.bubbleContainerCrop\n      .call(this._panZoom.dragRectangle)\n      .call(this._panZoom.zoomer)\n      .on(\"dblclick.zoom\", null)\n      .on(\"mouseup\", () => {\n        _this.draggingNow = false;\n      })\n      .on(\"click\", () => {\n        const cursor = _this.model.ui.cursorMode;\n        if (!d3.event.defaultPrevented && cursor !== \"arrow\" && cursor !== \"hand\") {\n          _this._panZoom.zoomByIncrement(cursor, 500);\n        }\n      });\n\n    this.KEY = this.model.entities.getDimension();\n    this.TIMEDIM = this.model.time.getDimension();\n\n    this.updateUIStrings();\n\n    this.wScale = d3.scale.linear()\n      .domain(this.model.ui.datawarning.doubtDomain)\n      .range(this.model.ui.datawarning.doubtRange);\n\n    this._labels.readyOnce();\n\n    _this._readyOnce = true;\n  },\n\n  _frameIsValid(frame) {\n    return !(!frame\n    || Object.keys(frame.axis_y).length === 0\n    || Object.keys(frame.axis_x).length === 0\n    || Object.keys(frame.size).length === 0);\n  },\n\n  ready() {\n    const _this = this;\n    this.KEY = this.model.entities.getDimension();\n    this.updateUIStrings();\n    const endTime = this.model.time.end;\n    this.updateIndicators();\n    this.updateTime();\n    if (!_this.model.time.splash) {\n      _this._trails.create();\n    }\n    this.model.marker.getFrame(this.model.time.value, (frame, time) => {\n      // TODO: temporary fix for case when after data loading time changed on validation\n      if (time.toString() != _this.model.time.value.toString()) {\n        utils.defer(() => {\n          _this.ready();\n        });\n        return;\n      }\n      if (!_this._frameIsValid(frame)) return utils.warn(\"ready: empty data received from marker.getFrame(). doing nothing\");\n\n      _this.frame = frame;\n      _this.updateSize();\n      _this.updateMarkerSizeLimits();\n      _this.updateEntities();\n      _this._labels.ready();\n      _this.redrawDataPoints();\n      _this.selectDataPoints();\n      _this.updateBubbleOpacity();\n      _this._updateDoubtOpacity();\n      _this.zoomToMarkerMaxMin(); // includes redraw data points and trail resize\n      if (!_this.model.time.splash) {\n        _this._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      }\n      if (_this.model.ui.adaptMinMaxZoom) _this._panZoom.expandCanvas();\n    });\n  },\n\n  /*\n   * Zoom to the min and max values given in the URL axes markers.\n   */\n  zoomToMarkerMaxMin() {\n    /*\n     * Reset just the zoom values without triggering a zoom event. This ensures\n     * a clean zoom state for the subsequent zoom event.\n     */\n    this._panZoom.resetZoomState();\n\n    const xAxis = this.model.marker.axis_x;\n    const yAxis = this.model.marker.axis_y;\n\n    const xDomain = xAxis.getScale().domain();\n    const yDomain = yAxis.getScale().domain();\n\n    /*\n     * The axes may return null when there is no value given for the zoomed\n     * min and max values. In that case, fall back to the axes' domain values.\n     */\n    const zoomedMinX = xAxis.getZoomedMin();\n    const zoomedMaxX = xAxis.getZoomedMax();\n    const zoomedMinY = yAxis.getZoomedMin();\n    const zoomedMaxY = yAxis.getZoomedMax();\n\n    //by default this will apply no transition and feed values back to state\n    this._panZoom.zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, 0, \"don't feed these zoom values back to state\");\n  },\n\n  /*\n   * UPDATE INDICATORS\n   */\n  updateIndicators() {\n    const _this = this;\n\n    //scales\n    this.yScale = this.model.marker.axis_y.getScale();\n    this.xScale = this.model.marker.axis_x.getScale();\n    this.sScale = this.model.marker.size.getScale();\n    this.cScale = this.model.marker.color.getScale();\n    this._labels.setScales(this.xScale, this.yScale);\n\n    this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());\n    this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());\n  },\n\n  frameChanged(frame, time) {\n//    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated\n    this.frame = frame;\n    this.updateTime();\n\n    this._updateDoubtOpacity();\n    this._trails.run(\"findVisible\");\n    if (this.model.ui.adaptMinMaxZoom) {\n      this._panZoom.expandCanvas();\n    } else {\n      this.redrawDataPoints();\n    }\n    this._trails.run(\"reveal\", null, this.duration);\n    this.tooltipMobile.classed(\"vzb-hidden\", true);\n    this._reorderEntities();\n  },\n\n  updateUIStrings() {\n    const _this = this;\n\n    const conceptPropsY = _this.model.marker.axis_y.getConceptprops();\n    const conceptPropsX = _this.model.marker.axis_x.getConceptprops();\n    const conceptPropsS = _this.model.marker.size.getConceptprops();\n    const conceptPropsC = _this.model.marker.color.getConceptprops();\n    this.translator = this.model.locale.getTFunction();\n\n    this.strings = {\n      title: {\n        Y: conceptPropsY.name,\n        X: conceptPropsX.name,\n        S: conceptPropsS.name,\n        C: conceptPropsC.name\n      },\n      unit: {\n        Y: conceptPropsY.unit || \"\",\n        X: conceptPropsX.unit || \"\",\n        S: conceptPropsS.unit || \"\",\n        C: conceptPropsC.unit || \"\"\n      }\n    };\n\n    const yTitle = this.yTitleEl.selectAll(\"text\").data([0]);\n    yTitle.enter().append(\"text\");\n    yTitle\n    //.attr(\"y\", \"-6px\")\n      .on(\"click\", () => {\n        _this.parent\n          .findChildByName(\"gapminder-treemenu\")\n          .markerID(\"axis_y\")\n          .alignX(_this.model.locale.isRTL() ? \"right\" : \"left\")\n          .alignY(\"top\")\n          .updateView()\n          .toggle();\n      });\n\n    const xTitle = this.xTitleEl.selectAll(\"text\").data([0]);\n    xTitle.enter().append(\"text\");\n    xTitle\n      .on(\"click\", () => {\n        _this.parent\n          .findChildByName(\"gapminder-treemenu\")\n          .markerID(\"axis_x\")\n          .alignX(_this.model.locale.isRTL() ? \"right\" : \"left\")\n          .alignY(\"bottom\")\n          .updateView()\n          .toggle();\n      });\n\n    const sTitle = this.sTitleEl.selectAll(\"text\").data([0]);\n    sTitle.enter().append(\"text\");\n    sTitle\n      .attr(\"text-anchor\", \"end\");\n\n    utils.setIcon(this.dataWarningEl, iconWarn).select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n    this.dataWarningEl.append(\"text\")\n      .attr(\"text-anchor\", \"end\")\n      .text(this.translator(\"hints/dataWarning\"));\n\n    utils.setIcon(this.yInfoEl, iconQuestion)\n      .select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n\n    utils.setIcon(this.xInfoEl, iconQuestion)\n      .select(\"svg\").attr(\"width\", \"0px\").attr(\"height\", \"0px\");\n\n\n    //TODO: move away from UI strings, maybe to ready or ready once\n    this.yInfoEl.on(\"click\", () => {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.yInfoEl.on(\"mouseover\", function() {\n      const rect = this.getBBox();\n      const coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      const toolRect = _this.root.element.getBoundingClientRect();\n      const chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_y\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.yInfoEl.on(\"mouseout\", () => {\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.xInfoEl.on(\"click\", () => {\n      _this.parent.findChildByName(\"gapminder-datanotes\").pin();\n    });\n    this.xInfoEl.on(\"mouseover\", function() {\n      if (_this.model.time.dragging) return;\n      const rect = this.getBBox();\n      const coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);\n      const toolRect = _this.root.element.getBoundingClientRect();\n      const chartRect = _this.element.node().getBoundingClientRect();\n      _this.parent.findChildByName(\"gapminder-datanotes\").setHook(\"axis_x\").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);\n    });\n    this.xInfoEl.on(\"mouseout\", () => {\n      if (_this.model.time.dragging) return;\n      _this.parent.findChildByName(\"gapminder-datanotes\").hide();\n    });\n    this.dataWarningEl\n      .on(\"click\", () => {\n        _this.parent.findChildByName(\"gapminder-datawarning\").toggle();\n      })\n      .on(\"mouseover\", () => {\n        _this._updateDoubtOpacity(1);\n      })\n      .on(\"mouseout\", () => {\n        _this._updateDoubtOpacity();\n      });\n  },\n\n  _updateDoubtOpacity(opacity) {\n    if (opacity == null) opacity = this.wScale(+this.model.time.formatDate(this.time));\n    if (this.someSelected) opacity = 1;\n    this.dataWarningEl.style(\"opacity\", opacity);\n  },\n\n  /*\n   * UPDATE ENTITIES:\n   * Ideally should only update when show parameters change or data changes\n   */\n  updateEntities() {\n    const _this = this;\n    const KEY = this.KEY;\n    const TIMEDIM = this.TIMEDIM;\n\n    const getKeys = function(prefix) {\n      prefix = prefix || \"\";\n      return _this.model.marker.getKeys()\n        .map(d => {\n          const pointer = {};\n          pointer[KEY] = d[KEY];\n          pointer[TIMEDIM] = endTime;\n          pointer.sortValue = _this.frame.size[d[KEY]] || 0;\n          pointer[KEY] = prefix + d[KEY];\n          return pointer;\n        })\n        .sort((a, b) => b.sortValue - a.sortValue);\n    };\n\n    // get array of GEOs, sorted by the size hook\n    // that makes larger bubbles go behind the smaller ones\n    const endTime = this.model.time.end;\n    const markers = getKeys.call(this);\n    this.model.marker.setVisible(markers);\n\n    //unselecting bubbles with no data is used for the scenario when\n    //some bubbles are selected and user would switch indicator.\n    //bubbles would disappear but selection would stay\n    if (!this.model.time.splash) {\n      this.unselectBubblesWithNoData(markers);\n    }\n    this.entityBubbles = this.bubbleContainer.selectAll(\"circle.vzb-bc-entity\")\n      .data(this.model.marker.getVisible(), d => d[KEY]); // trails have not keys\n\n    //exit selection\n    this.entityBubbles.exit().remove();\n\n    //enter selection -- init circles\n    this.entityBubbles = this.entityBubbles.enter().append(\"circle\")\n      .attr(\"class\", d => \"vzb-bc-entity \" + \"bubble-\" + d[KEY])\n      .on(\"mouseover\", (d, i) => {\n        if (utils.isTouchDevice() || (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\")) return;\n        _this._bubblesInteract().mouseover(d, i);\n      })\n      .on(\"mouseout\", (d, i) => {\n        if (utils.isTouchDevice() || (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\")) return;\n\n        _this._bubblesInteract().mouseout(d, i);\n      })\n      .on(\"click\", (d, i) => {\n        if (utils.isTouchDevice() || (_this.model.ui.cursorMode !== \"arrow\" && _this.model.ui.cursorMode !== \"hand\")) return;\n\n        _this._bubblesInteract().click(d, i);\n      })\n      .onTap((d, i) => {\n        d3.event.stopPropagation();\n        _this._bubblesInteract().click(d, i);\n      })\n      .onLongTap((d, i) => {\n      })\n      .merge(this.entityBubbles);\n\n    this._reorderEntities();\n  },\n\n  unselectBubblesWithNoData(entities) {\n    const _this = this;\n    const KEY = this.KEY;\n    if (!this.model.marker.select.length) return;\n\n    const _select = [];\n    const keys = entities.map(d => d[KEY]);\n\n    this.model.marker.select.forEach(d => {\n      if (keys.indexOf(d[KEY]) !== -1) _select.push(d);\n    });\n\n    if (_select.length !== _this.model.marker.select.length) _this.model.marker.select = _select;\n  },\n\n  _reorderEntities() {\n    const _this = this;\n    const KEY = this.KEY;\n    this.bubbleContainer.selectAll(\".vzb-bc-entity\")\n      .sort((a, b) => {\n        const sizeA = _this.frame.size[a[KEY]];\n        const sizeB = _this.frame.size[b[KEY]];\n\n        if (typeof sizeA === \"undefined\" && typeof sizeB !== \"undefined\") return -1;\n        if (typeof sizeA !== \"undefined\" && typeof sizeB === \"undefined\") return 1;\n        if (sizeA != sizeB) return d3.descending(sizeA, sizeB);\n        if (a[KEY] != b[KEY]) return d3.ascending(a[KEY], b[KEY]);\n        if (typeof a.trailStartTime !== \"undefined\" || typeof b.trailStartTime !== \"undefined\") return typeof a.trailStartTime !== \"undefined\" ? -1 : 1; // only lines has trailStartTime\n        if (typeof a.limits !== \"undefined\" || typeof b.limits !== \"undefined\") return typeof a.limits !== \"undefined\" ? -1 : 1; // only trails has attribute limits\n        return d3.descending(sizeA, sizeB);\n      });\n  },\n\n  _bubblesInteract() {\n    const _this = this;\n    const KEY = this.KEY;\n    const TIMEDIM = this.TIMEDIM;\n\n    return {\n      mouseover(d, i) {\n        _this.model.marker.highlightMarker(d);\n\n        _this._labels.showCloseCross(d, true);\n      },\n\n      mouseout(d, i) {\n        _this.model.marker.clearHighlighted();\n\n        _this._labels.showCloseCross(d, false);\n      },\n\n      click(d, i) {\n        if (_this.draggingNow) return;\n        const isSelected = _this.model.marker.isSelected(d);\n        _this.model.marker.selectMarker(d);\n        //return to highlighted state\n        if (!utils.isTouchDevice()) {\n          if (isSelected) _this.model.marker.highlightMarker(d);\n          _this.highlightDataPoints();\n        }\n      }\n    };\n  },\n\n\n  /*\n   * UPDATE TIME:\n   * Ideally should only update when time or data changes\n   */\n  updateTime() {\n    const _this = this;\n\n    this.time_1 = this.time == null ? this.model.time.value : this.time;\n    this.time = this.model.time.value;\n    this.duration = this.model.time.playing && (this.time - this.time_1 > 0) ? this.model.time.delayAnimations : 0;\n    this.year.setText(this.model.time.formatDate(this.time, \"ui\"), this.duration);\n  },\n\n  /*\n   * RESIZE:\n   * Executed whenever the container is resized\n   */\n  updateSize() {\n\n\n    const profiles = {\n      small: {\n        margin: { top: 30, right: 10, left: 40, bottom: 35 },\n        padding: 2,\n        minRadiusPx: 0.5,\n        maxRadiusEm: 0.05,\n        infoElHeight: 16,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 4\n      },\n      medium: {\n        margin: { top: 40, right: 15, left: 60, bottom: 55 },\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: 0.05,\n        infoElHeight: 20,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 5\n      },\n      large: {\n        margin: { top: 50, right: 20, left: 60, bottom: 60 },\n        padding: 2,\n        minRadiusPx: 1,\n        maxRadiusEm: 0.05,\n        infoElHeight: 22,\n        yAxisTitleBottomMargin: 6,\n        xAxisTitleBottomMargin: 5,\n        hideSTitle: true\n      }\n    };\n\n    const presentationProfileChanges = {\n      \"medium\": {\n        margin: { top: 80, bottom: 80, left: 100 },\n        yAxisTitleBottomMargin: 20,\n        xAxisTitleBottomMargin: 20,\n        infoElHeight: 26,\n      },\n      \"large\": {\n        margin: { top: 80, bottom: 100, left: 100 },\n        yAxisTitleBottomMargin: 20,\n        xAxisTitleBottomMargin: 20,\n        infoElHeight: 32,\n        hideSTitle: true\n      }\n    };\n\n    const _this = this;\n\n    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);\n\n    const containerWH = this.root.getVizWidthHeight();\n    this.activeProfile.maxRadiusPx = Math.max(\n      this.activeProfile.minRadiusPx,\n      this.activeProfile.maxRadiusEm * utils.hypotenuse(containerWH.width, containerWH.height)\n    );\n\n    const margin = this.activeProfile.margin;\n    const infoElHeight = this.activeProfile.infoElHeight;\n\n    //labels\n    _this._labels.setCloseCrossHeight(_this.activeProfile.infoElHeight * 1.2);\n\n    //stage\n    this.height = (parseInt(this.element.style(\"height\"), 10) - margin.top - margin.bottom) || 0;\n    this.width = (parseInt(this.element.style(\"width\"), 10) - margin.left - margin.right) || 0;\n\n    if (this.height <= 0 || this.width <= 0) {\n      this.height = 0;\n      this.width = 0;\n      utils.warn(\"Bubble chart updateSize(): vizabi container is too little or has display:none\");\n    }\n\n    //graph group is shifted according to margins (while svg element is at 100 by 100%)\n    this.graph\n      .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    this.year.resize(this.width, this.height);\n    this.eventArea\n      .attr(\"width\", this.width)\n      .attr(\"height\", Math.max(0, this.height));\n\n    //update scales to the new range\n    if (this.model.marker.axis_y.scaleType !== \"ordinal\") {\n      this.yScale.range(this._rangeBump([this.height, 0]));\n    } else {\n      this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();\n    }\n    if (this.model.marker.axis_x.scaleType !== \"ordinal\") {\n      this.xScale.range(this._rangeBump([0, this.width]));\n    } else {\n      this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();\n    }\n\n    //apply scales to axes and redraw\n    this.yAxis.scale(this.yScale)\n      .tickSizeInner(-this.width)\n      .tickSizeOuter(0)\n      .tickPadding(6)\n      .tickSizeMinor(-this.width, 0)\n      .labelerOptions({\n        scaleType: this.model.marker.axis_y.scaleType,\n        toolMargin: margin,\n        limitMaxTickNumber: 6,\n        bump: this.activeProfile.maxRadiusPx / 2,\n        viewportLength: this.height,\n        formatter: this.model.marker.axis_y.getTickFormatter()\n      });\n\n    this.xAxis.scale(this.xScale)\n      .tickSizeInner(-this.height)\n      .tickSizeOuter(0)\n      .tickPadding(6)\n      .tickSizeMinor(-this.height, 0)\n      .labelerOptions({\n        scaleType: this.model.marker.axis_x.scaleType,\n        toolMargin: margin,\n        bump: this.activeProfile.maxRadiusPx / 2,\n        viewportLength: this.width,\n        formatter: this.model.marker.axis_x.getTickFormatter()\n      });\n\n\n    this.bubbleContainerCrop\n      .attr(\"width\", this.width)\n      .attr(\"height\", Math.max(0, this.height));\n\n    this.labelsContainerCrop\n      .attr(\"width\", this.width)\n      .attr(\"height\", Math.max(0, this.height));\n\n    this.xAxisElContainer\n      .attr(\"width\", this.width + 1)\n      .attr(\"height\", this.activeProfile.margin.bottom + this.height)\n      .attr(\"y\", -1)\n      .attr(\"x\", -1);\n    this.xAxisEl\n      .attr(\"transform\", \"translate(1,\" + (1 + this.height) + \")\");\n\n    this.yAxisElContainer\n      .attr(\"width\", this.activeProfile.margin.left + this.width)\n      .attr(\"height\", Math.max(0, this.height))\n      .attr(\"x\", -this.activeProfile.margin.left);\n    this.yAxisEl\n      .attr(\"transform\", \"translate(\" + (this.activeProfile.margin.left - 1) + \",\" + 0 + \")\");\n\n    this.yAxisEl.call(this.yAxis);\n    this.xAxisEl.call(this.xAxis);\n\n    this.projectionX.attr(\"y1\", _this.yScale.range()[0] + this.activeProfile.maxRadiusPx / 2);\n    this.projectionY.attr(\"x2\", _this.xScale.range()[0] - this.activeProfile.maxRadiusPx / 2);\n\n\n    // reduce font size if the caption doesn't fit\n    this._updateSTitle();\n    this.sTitleEl\n      .attr(\"transform\", \"translate(\" + this.width + \",\" + 20 + \") rotate(-90)\");\n\n    const isRTL = this.model.locale.isRTL();\n    this.yTitleEl\n      .style(\"font-size\", infoElHeight + \"px\")\n      .attr(\"transform\", \"translate(\" + (isRTL ? this.width : 10 - this.activeProfile.margin.left) + \", -\" + this.activeProfile.yAxisTitleBottomMargin + \")\");\n\n    this.xTitleEl\n      .style(\"font-size\", infoElHeight + \"px\")\n      .attr(\"transform\", \"translate(\" + (isRTL ? this.width : 0) + \",\" + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + \")\");\n\n    const ySeparator = this.strings.unit.Y ? \", \" : \"\";\n    const yTitleText = this.yTitleEl.select(\"text\").text(this.strings.title.Y + ySeparator + this.strings.unit.Y);\n    if (yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title.Y);\n\n    const xSeparator = this.strings.unit.Y ? \", \" : \"\";\n    const xTitleText = this.xTitleEl.select(\"text\").text(this.strings.title.X + xSeparator + this.strings.unit.X);\n    if (xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title.X);\n\n    if (this.yInfoEl.select(\"svg\").node()) {\n      const titleBBox = this.yTitleEl.node().getBBox();\n      const t = utils.transform(this.yTitleEl.node());\n      const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);\n\n      this.yInfoEl.select(\"svg\")\n        .attr(\"width\", infoElHeight + \"px\")\n        .attr(\"height\", infoElHeight + \"px\");\n      this.yInfoEl.attr(\"transform\", \"translate(\"\n        + hTranslate + \",\"\n        + (t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    if (this.xInfoEl.select(\"svg\").node()) {\n      const titleBBox = this.xTitleEl.node().getBBox();\n      const t = utils.transform(this.xTitleEl.node());\n      const hTranslate = isRTL ? (titleBBox.x + t.translateX - infoElHeight * 1.4) : (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4);\n\n      this.xInfoEl.select(\"svg\")\n        .attr(\"width\", infoElHeight + \"px\")\n        .attr(\"height\", infoElHeight + \"px\");\n      this.xInfoEl.attr(\"transform\", \"translate(\"\n        + hTranslate + \",\"\n        + (t.translateY - infoElHeight * 0.8) + \")\");\n    }\n\n    this._resizeDataWarning();\n  },\n\n\n  _updateLineEqualXY(duration) {\n    const oneMeasure = this.model.marker.axis_x.which == this.model.marker.axis_y.which;\n    this.lineEqualXY.classed(\"vzb-invisible\", !oneMeasure);\n    if (!oneMeasure) return;\n\n    const min = d3.min(this.yScale.domain().concat(this.xScale.domain()));\n    const max = d3.max(this.yScale.domain().concat(this.xScale.domain()));\n\n    this.lineEqualXY\n      .transition()\n      .duration(duration || 0)\n      .attr(\"y1\", this.yScale(min))\n      .attr(\"y2\", this.yScale(max))\n      .attr(\"x1\", this.xScale(min))\n      .attr(\"x2\", this.xScale(max));\n  },\n\n  _resizeDataWarning() {\n    // reset font size to remove jumpy measurement\n    const dataWarningText = this.dataWarningEl.select(\"text\").style(\"font-size\", null);\n\n    // reduce font size if the caption doesn't fit\n    const dataWarningWidth = dataWarningText.node().getBBox().width + dataWarningText.node().getBBox().height * 3;\n    const remainingWidth = this.width - this.xTitleEl.node().getBBox().width - this.activeProfile.infoElHeight;\n    const font = parseInt(dataWarningText.style(\"font-size\")) * remainingWidth / dataWarningWidth;\n    dataWarningText.style(\"font-size\", dataWarningWidth > remainingWidth ? font + \"px\" : null);\n\n    // position the warning icon\n    const warnBB = dataWarningText.node().getBBox();\n    this.dataWarningEl.select(\"svg\")\n      .attr(\"width\", warnBB.height * 0.75)\n      .attr(\"height\", warnBB.height * 0.75)\n      .attr(\"x\", -warnBB.width - warnBB.height * 1.2)\n      .attr(\"y\", -warnBB.height * 0.65);\n\n    this.dataWarningEl\n      .attr(\"transform\", \"translate(\"\n        + (this.model.locale.isRTL() ? warnBB.width + warnBB.height : this.width) + \",\"\n        + (this.height + this.activeProfile.margin.bottom - this.activeProfile.xAxisTitleBottomMargin)\n        + \")\");\n  },\n\n  updateMarkerSizeLimits() {\n    const _this = this;\n    const extent = this.model.marker.size.extent || [0, 1];\n\n    if (!this.activeProfile) return utils.warn(\"updateMarkerSizeLimits() is called before ready(). This can happen if events get unfrozen and getFrame() still didn't return data\");\n\n    let minRadius = this.activeProfile.minRadiusPx;\n    let maxRadius = this.activeProfile.maxRadiusPx;\n\n    let minArea = utils.radiusToArea(Math.max(maxRadius * extent[0], minRadius));\n    let maxArea = utils.radiusToArea(Math.max(maxRadius * extent[1], minRadius));\n\n    let range = minArea === maxArea? [minArea, maxArea] :\n      d3.range(minArea, maxArea, (maxArea - minArea)/this.sScale.domain().length).concat(maxArea);\n\n    this.sScale.range(range);\n  },\n\n  redrawDataPointsOnlyColors() {\n    const _this = this;\n    if (!this.entityBubbles) return utils.warn(\"redrawDataPointsOnlyColors(): no entityBubbles defined. likely a premature call, fix it!\");\n\n    let valuesNow;\n    const KEY = this.KEY;\n\n\n    let time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, valuesLocked => {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function(d, index) {\n\n        const selected = _this.model.marker.isSelected(d);\n\n        const valueC = selected ? valuesNow.color[d[KEY]] : valuesLocked.color[d[KEY]];\n\n        const scaledC = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;\n\n        d3.select(this).style(\"fill\", scaledC);\n\n        //update lines of labels\n        if (selected) {\n\n          const select = utils.find(_this.model.marker.select, f => f[KEY] == d[KEY]);\n\n          const trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, valuesTrailStart => {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlyColor: empty data received from marker.getFrames(). doing nothing\");\n\n            const cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledC0 = scaledC;\n            } else {\n              const valueC = valuesTrailStart.color[d[KEY]];\n              cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;\n            }\n\n            _this._labels.updateLabelOnlyColor(d, index, cache);\n\n          });\n        }\n      });\n    });\n\n  },\n\n  redrawDataPointsOnlySize() {\n    const _this = this;\n\n    let valuesNow;\n    const KEY = this.KEY;\n\n\n    let time = this.model.time.value;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n    }\n    this.model.marker.getFrame(time, valuesLocked => {\n      if (!_this._frameIsValid(valuesLocked)) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrame(). doing nothing\");\n\n      valuesNow = _this.frame;\n      _this.entityBubbles.each(function(d, index) {\n\n        const selected = _this.model.marker.isSelected(d);\n\n        const valueS = selected ? valuesNow.size[d[KEY]] : valuesLocked.size[d[KEY]];\n        if (valueS == null) return;\n\n        const scaledS = utils.areaToRadius(_this.sScale(valueS));\n        d3.select(this).attr(\"r\", scaledS);\n\n        //update lines of labels\n        if (selected) {\n\n          const select = utils.find(_this.model.marker.select, f => f[KEY] == d[KEY]);\n\n          const trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n          _this.model.marker.getFrame(trailStartTime, valuesTrailStart => {\n            if (!valuesTrailStart) return utils.warn(\"redrawDataPointsOnlySize: empty data received from marker.getFrames(). doing nothing\");\n\n            const cache = {};\n            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {\n              cache.scaledS0 = scaledS;\n            } else {\n              cache.scaledS0 = utils.areaToRadius(_this.sScale(valuesTrailStart.size[d[KEY]]));\n            }\n\n            _this._labels.updateLabelOnlyPosition(d, index, cache);\n\n          });\n        }\n      });\n    });\n  },\n\n  /*\n   * REDRAW DATA POINTS:\n   * Here plotting happens\n   * debouncing to improve performance: events might trigger it more than 1x\n   */\n  redrawDataPoints(duration) {\n    const _this = this;\n    const KEY = this.KEY;\n    if (duration == null) duration = _this.duration;\n\n    if (this.model.ui.chart.lockNonSelected && this.someSelected) {\n      const time = this.model.time.parse(\"\" + this.model.ui.chart.lockNonSelected);\n\n      //get values for locked frames\n      this.model.marker.getFrame(time, lockedFrame => {\n        if (!lockedFrame) return utils.warn(\"redrawDataPoints: empty data received from marker.getFrames(). doing nothing\");\n\n        // each bubble\n        _this.entityBubbles.each(function(d, index) {\n          const frame = _this.model.marker.isSelected(d) ? _this.frame : lockedFrame;\n          _this._updateBubble(d, frame, index, d3.select(this), duration);\n        });\n      });\n    } else {\n      // each bubble\n      _this.entityBubbles.each(function(d, index) {\n        _this._updateBubble(d, _this.frame, index, d3.select(this), duration);\n      });\n    }\n\n    this._updateLineEqualXY(duration);\n  },\n\n  //redraw Data Points\n  _updateBubble(d, values, index, view, duration) {\n    const _this = this;\n    const KEY = this.KEY;\n\n    let showhide = false;\n\n    const valueY = values.axis_y[d[KEY]];\n    const valueX = values.axis_x[d[KEY]];\n    const valueS = values.size[d[KEY]];\n    const valueL = values.label[d[KEY]];\n    const valueC = values.color[d[KEY]];\n    const valueLST = values.size_label[d[KEY]];\n\n    // check if fetching data succeeded\n    if (!valueL && valueL !== 0 || !valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) {\n      // if entity is missing data it should hide\n      if (!d.hidden) {\n        d.hidden = true;\n        showhide = true;\n      }\n\n      if (showhide) {\n        if (duration) {\n          const opacity = view.style(\"opacity\");\n          view.transition().duration(duration).ease(d3.easeExp)\n            .style(\"opacity\", 0)\n            .on(\"end\", () => {\n              //to avoid transition from null state add class with a delay\n              view.classed(\"vzb-invisible\", d.hidden);\n              view.style(\"opacity\", opacity);\n            });\n        } else {\n          //immediately hide the bubble\n          view.classed(\"vzb-invisible\", d.hidden);\n        }\n      }\n    } else {\n      if (d.hidden || view.classed(\"vzb-invisible\")) {\n        d.hidden = false;\n        showhide = true;\n      }\n\n\n      // if entity has all the data we update the visuals\n      const scaledS = utils.areaToRadius(_this.sScale(valueS));\n\n      view.style(\"fill\", valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH);\n\n      if (duration) {\n        if (showhide) {\n          const opacity = view.style(\"opacity\");\n          view.classed(\"vzb-invisible\", d.hidden);\n          view.style(\"opacity\", 0)\n            .attr(\"cy\", _this.yScale(valueY))\n            .attr(\"cx\", _this.xScale(valueX))\n            .attr(\"r\", scaledS)\n            .transition().duration(duration).ease(d3.easeExp)\n            .style(\"opacity\", opacity);\n        } else {\n          view.transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"cy\", _this.yScale(valueY))\n            .attr(\"cx\", _this.xScale(valueX))\n            .attr(\"r\", scaledS);\n        }\n\n      } else {\n\n        //interrupt the ongoing transition and immediately do the visual updates\n        view.interrupt()\n          .attr(\"cy\", _this.yScale(valueY))\n          .attr(\"cx\", _this.xScale(valueX))\n          .attr(\"r\", scaledS)\n          .transition();\n\n        //show entity if it was hidden\n        if (showhide) view.classed(\"vzb-invisible\", d.hidden);\n      }\n\n      if (this.model.time.record) _this._export.write({\n        type: \"circle\",\n        id: d[KEY],\n        time: this.model.time.value.getUTCFullYear(),\n        fill: valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH,\n        cx: _this.xScale(valueX),\n        cy: _this.yScale(valueY),\n        r: scaledS\n      });\n\n    } // data exists\n    _this._updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide);\n  },\n\n  _updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {\n    const _this = this;\n    const KEY = this.KEY;\n\n    // only for selected markers\n    if (_this.model.marker.isSelected(d)) {\n\n      const cache = {};\n\n      const select = utils.find(_this.model.marker.select, f => f[KEY] == d[KEY]);\n\n      const time = _this.model.time.formatDate(_this.time);\n      if (!this.model.ui.chart.trails || select.trailStartTime == time || select.trailStartTime == null) {\n        if (this.model.ui.chart.trails && select.trailStartTime == null) select.trailStartTime = time; // need only when trailStartTime == null\n\n        cache.labelX0 = valueX;\n        cache.labelY0 = valueY;\n        cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH,\n          cache.scaledS0 = (valueS || valueS === 0) ? utils.areaToRadius(_this.sScale(valueS)) : null;\n      }\n\n      const trailStartTime = _this.model.time.parse(\"\" + select.trailStartTime);\n\n      const labelText = valueL + (_this.model.ui.chart.trails ? \" \" + select.trailStartTime : \"\");\n\n      if (showhide && d.hidden && _this.model.ui.chart.trails && trailStartTime && (trailStartTime < _this.time)) showhide = false;\n      if (d.hidden && !_this.model.ui.chart.trails) showhide = true;\n\n      this._labels.updateLabel(d, index, cache, valueX, valueY, valueS, valueC, labelText, valueLST, duration, showhide);\n\n    }\n  },\n\n  _formatSTitleValues(titleS, titleC) {\n    const _this = this;\n    const unitS = this.strings.unit.S;\n    const unitC = this.strings.unit.C;\n\n    const formatterS = this.model.marker.size.getTickFormatter();\n    const formatterC = this.model.marker.color.getTickFormatter();\n\n    //resolve labels for colors via the color legend\n    if (this.model.marker.color.isDiscrete() && this.model.marker.color.use !== \"constant\" && titleC && this.model.marker.color.getColorlegendMarker()) {\n      titleC = this.model.marker.color.getColorlegendMarker().label.getItems()[titleC] || \"\";\n    }\n\n    return [formatterS(titleS) + \" \" + unitS,\n      titleC || titleC === 0 ? formatterC(titleC) + \" \" + unitC : this.translator(\"hints/nodata\")];\n  },\n\n  _updateSTitle(titleS, titleC) {\n\n    // vertical text about size and color\n    if (this.activeProfile.hideSTitle\n      && this.model.ui.dialogs.sidebar.indexOf(\"colors\") > -1\n      && this.model.ui.dialogs.sidebar.indexOf(\"size\") > -1) {\n      this.sTitleEl.classed(\"vzb-invisible\", true);\n      return;\n    }\n    if (this.sTitleEl.classed(\"vzb-invisible\")) {\n      this.sTitleEl.classed(\"vzb-invisible\", false);\n    }\n    const sTitleContentON = this.model.marker.size.use !== \"constant\";\n    const cTitleContentON = this.model.marker.color.use !== \"constant\";\n    const sTitleText = this.sTitleEl.select(\"text\")\n    // reset font size to remove jumpy measurement\n      .style(\"font-size\", null)\n      .text(\n        (sTitleContentON ? this.translator(\"buttons/size\") + \": \" + (titleS ? titleS : this.strings.title.S) : \"\") +\n        (sTitleContentON && cTitleContentON ? \", \" : \"\") +\n        (cTitleContentON ? this.translator(\"buttons/colors\") + \": \" + (titleC ? titleC : this.strings.title.C) : \"\")\n      );\n    const sTitleWidth = sTitleText.node().getBBox().width;\n    const remainigHeight = this.height - 30;\n    const font = parseInt(sTitleText.style(\"font-size\")) * remainigHeight / sTitleWidth;\n    sTitleText.style(\"font-size\", sTitleWidth > remainigHeight ? font + \"px\" : null);\n  },\n\n  selectDataPoints() {\n    const _this = this;\n    const KEY = this.KEY;\n\n    if (utils.isTouchDevice()) {\n      _this.model.marker.clearHighlighted();\n      _this._labels.showCloseCross(null, false);\n    } else {\n      //hide tooltip\n      _this._setTooltip();\n      _this._setBubbleCrown();\n    }\n\n    _this.someSelected = (_this.model.marker.select.length > 0);\n    _this.nonSelectedOpacityZero = false;\n  },\n\n  _setBubbleCrown(x, y, r, glow, skipInnerFill) {\n    if (x != null) {\n      this.bubbleCrown.classed(\"vzb-hidden\", false);\n      this.bubbleCrown.select(\".vzb-crown\")\n        .attr(\"cx\", x)\n        .attr(\"cy\", y)\n        .attr(\"r\", r)\n        .attr(\"fill\", skipInnerFill ? \"none\" : glow);\n      this.bubbleCrown.selectAll(\".vzb-crown-glow\")\n        .attr(\"cx\", x)\n        .attr(\"cy\", y)\n        .attr(\"r\", r + 10)\n        .attr(\"stroke\", glow);\n\n    } else {\n      this.bubbleCrown.classed(\"vzb-hidden\", true);\n    }\n\n  },\n\n  _setTooltip(tooltipText, x, y, offset, glow) {\n    if (tooltipText) {\n      let xPos, yPos, xSign = -1,\n        ySign = -1,\n        xOffset = 0,\n        yOffset = 0;\n\n      if (offset) {\n        xOffset = offset * 0.71; // .71 - sin and cos for 315\n        yOffset = offset * 0.71;\n      }\n      //position tooltip\n      this.tooltip.classed(\"vzb-hidden\", false)\n      //.attr(\"style\", \"left:\" + (mouse[0] + 50) + \"px;top:\" + (mouse[1] + 50) + \"px\")\n        .selectAll(\"text\")\n        .text(tooltipText);\n\n      const contentBBox = this.tooltip.select(\"text\").node().getBBox();\n      if (x - xOffset - contentBBox.width < 0) {\n        xSign = 1;\n        x += contentBBox.width + 5; // corrective to the block Radius and text padding\n      } else {\n        x -= 5; // corrective to the block Radius and text padding\n      }\n      if (y - yOffset - contentBBox.height < 0) {\n        ySign = 1;\n        y += contentBBox.height;\n      } else {\n        y -= 11; // corrective to the block Radius and text padding\n      }\n      if (offset) {\n        xPos = x + xOffset * xSign;\n        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding\n      } else {\n        xPos = x + xOffset * xSign; // .71 - sin and cos for 315\n        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding\n      }\n      this.tooltip.attr(\"transform\", \"translate(\" + xPos + \",\" + yPos + \")\");\n\n      this.tooltip.selectAll(\"rect\")\n        .attr(\"width\", contentBBox.width + 8)\n        .attr(\"height\", contentBBox.height * 1.2)\n        .attr(\"x\", -contentBBox.width - 4)\n        .attr(\"y\", -contentBBox.height * 0.85)\n        .attr(\"rx\", contentBBox.height * 0.2)\n        .attr(\"ry\", contentBBox.height * 0.2);\n\n      this.tooltip.select(\".vzb-tooltip-glow\")\n        .attr(\"stroke\", glow);\n\n    } else {\n      this.tooltip.classed(\"vzb-hidden\", true);\n    }\n  },\n\n  /*\n   * Shows and hides axis projections\n   */\n  _axisProjections(d) {\n    const _this = this;\n    const TIMEDIM = this.TIMEDIM;\n    const KEY = this.KEY;\n\n    if (d != null) {\n\n      this.model.marker.getFrame(d[TIMEDIM], values => {\n        const valueY = values.axis_y[d[KEY]];\n        const valueX = values.axis_x[d[KEY]];\n        const valueS = values.size[d[KEY]];\n        const radius = utils.areaToRadius(_this.sScale(valueS));\n\n        if (!valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) return;\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineX\n          && _this.xScale(valueX) > 0 && _this.xScale(valueX) < _this.width\n          && (_this.yScale(valueY) + radius) < _this.height) {\n          _this.projectionX\n            .style(\"opacity\", 1)\n            .attr(\"y2\", _this.yScale(valueY) + radius)\n            .attr(\"x1\", _this.xScale(valueX))\n            .attr(\"x2\", _this.xScale(valueX));\n        }\n\n        if (_this.model.ui.chart.whenHovering.showProjectionLineY\n          && _this.yScale(valueY) > 0 && _this.yScale(valueY) < _this.height\n          && (_this.xScale(valueX) - radius) > 0) {\n          _this.projectionY\n            .style(\"opacity\", 1)\n            .attr(\"y1\", _this.yScale(valueY))\n            .attr(\"y2\", _this.yScale(valueY))\n            .attr(\"x1\", _this.xScale(valueX) - radius);\n        }\n\n        if (_this.model.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(\n          _this.xAxis.highlightValue(valueX)\n        );\n\n        if (_this.model.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(\n          _this.yAxis.highlightValue(valueY)\n        );\n      });\n\n    } else {\n\n      this.projectionX.style(\"opacity\", 0);\n      this.projectionY.style(\"opacity\", 0);\n      this.xAxisEl.call(this.xAxis.highlightValue(\"none\"));\n      this.yAxisEl.call(this.yAxis.highlightValue(\"none\"));\n\n    }\n\n  },\n\n  /*\n   * Highlights all hovered bubbles\n   */\n  highlightDataPoints() {\n    const _this = this;\n    const TIMEDIM = this.TIMEDIM;\n    const KEY = this.KEY;\n\n    this.someHighlighted = (this.model.marker.highlight.length > 0);\n\n    this.updateBubbleOpacity();\n\n    if (this.model.marker.highlight.length === 1) {\n      const d = utils.clone(this.model.marker.highlight[0]);\n\n      if (_this.model.ui.chart.lockNonSelected && _this.someSelected && !_this.model.marker.isSelected(d)) {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + _this.model.ui.chart.lockNonSelected);\n      } else {\n        d[TIMEDIM] = _this.model.time.parse(\"\" + d.trailStartTime) || _this.time;\n      }\n\n      _this.model.marker.getFrame(d[TIMEDIM], values => {\n        if (!values) return;\n        const x = _this.xScale(values.axis_x[d[KEY]]);\n        const y = _this.yScale(values.axis_y[d[KEY]]);\n        const s = utils.areaToRadius(_this.sScale(values.size[d[KEY]]));\n        const c = values.color[d[KEY]] != null ? _this.cScale(values.color[d[KEY]]) : _this.COLOR_WHITEISH;\n        let entityOutOfView = false;\n\n        const titles = _this._formatSTitleValues(values.size[d[KEY]], values.color[d[KEY]]);\n        _this._updateSTitle(titles[0], titles[1]);\n        if (x + s < 0 || x - s > _this.width || y + s < 0 || y - s > _this.height) {\n          entityOutOfView = true;\n        }\n\n        //show tooltip\n        let text = \"\";\n        let hoverTrail = false;\n        if (_this.model.marker.isSelected(d) && _this.model.ui.chart.trails) {\n          text = _this.model.time.formatDate(_this.time);\n          const selectedData = utils.find(_this.model.marker.select, f => f[KEY] == d[KEY]);\n          hoverTrail = text !== selectedData.trailStartTime && !d3.select(d3.event.target).classed(\"bubble-\" + d[KEY]);\n          text = text !== selectedData.trailStartTime && _this.time === d[TIMEDIM] ? text : \"\";\n        } else {\n          text = _this.model.marker.isSelected(d) ? \"\" : values.label[d[KEY]];\n        }\n\n        _this._labels.highlight(null, false);\n        _this._labels.highlight(d, true);\n        if (_this.model.marker.isSelected(d)) {\n          const skipCrownInnerFill = !d.trailStartTime || d.trailStartTime == _this.model.time.formatDate(_this.time);\n          _this._setBubbleCrown(x, y, s, c, skipCrownInnerFill);\n        }\n\n        if (!entityOutOfView && !hoverTrail) {\n          _this._axisProjections(d);\n        }\n\n        //set tooltip and show axis projections\n        if (text && !entityOutOfView && !hoverTrail) {\n          _this._setTooltip(text, x, y, s + 3, c);\n        }\n\n        const selectedData = utils.find(_this.model.marker.select, f => f[KEY] == d[KEY]);\n        if (selectedData) {\n          const clonedSelectedData = utils.clone(selectedData);\n          //change opacity to OPACITY_HIGHLT = 1.0;\n          clonedSelectedData.opacity = 1.0;\n          _this._trails.run([\"opacityHandler\"], clonedSelectedData);\n        }\n      });\n    } else {\n      this._axisProjections();\n      this._trails.run([\"opacityHandler\"]);\n      //hide tooltip\n      _this._updateSTitle();\n      this._setTooltip();\n      this._setBubbleCrown();\n      this._labels.highlight(null, false);\n    }\n\n  },\n\n  updateBubbleOpacity(duration) {\n    const _this = this;\n    //if(!duration)duration = 0;\n\n    const OPACITY_HIGHLT = 1.0;\n    const OPACITY_HIGHLT_DIM = this.model.marker.opacityHighlightDim;\n    const OPACITY_SELECT = this.model.marker.opacityRegular;\n    const OPACITY_REGULAR = this.model.marker.opacityRegular;\n    const OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;\n\n    this.entityBubbles\n    //.transition().duration(duration)\n      .style(\"opacity\", d => {\n\n        if (_this.someHighlighted) {\n          //highlight or non-highlight\n          if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;\n        }\n\n        if (_this.someSelected) {\n          //selected or non-selected\n          return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;\n        }\n\n        if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;\n\n        return OPACITY_REGULAR;\n      });\n\n\n    const nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n\n    // when pointer events need update...\n    if (nonSelectedOpacityZero != this.nonSelectedOpacityZero) {\n      this.entityBubbles.style(\"pointer-events\", d => (!_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d)) ?\n        \"visible\" : \"none\");\n    }\n\n    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;\n  }\n\n});\n\nexport default BubbleChart;\n\n\n\n// WEBPACK FOOTER //\n// ./src/component.js","const { utils } = Vizabi;\n\nconst PanZoom = Vizabi.Class.extend({\n\n  init(context) {\n    this.context = context;\n\n    this.dragRectangle = d3.drag();\n    this.zoomer = d3.zoom();\n\n    // this.dragLock = false;\n\n    this.dragRectangle\n      .subject(this.dragSubject())\n      .on(\"start\", this.drag().start)\n      .on(\"drag\", this.drag().go)\n      .on(\"end\", this.drag().stop);\n\n    this.zoomer\n      .filter(this.zoomFilter())\n      .scaleExtent([0.0625, +Infinity])\n      .on(\"start\", this.zoom().start)\n      .on(\"zoom\", this.zoom().go)\n      .on(\"end\", this.zoom().stop);\n\n    this.zoomer.ratioX = 1;\n    this.zoomer.ratioY = 1;\n\n    context._zoomedXYMinMax = {\n      axis_x: { zoomedMin: null, zoomedMax: null },\n      axis_y: { zoomedMin: null, zoomedMax: null }\n    };\n  },\n\n  dragSubject() {\n    const _this = this.context;\n    const self = this;\n\n    return function(d) {\n      /*\n       * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n       * not enabled. Also do not drag if zoom-pinching on touchmove\n       * events.\n       */\n      if (!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||\n        _this.ui.cursorMode === \"plus\") || (_this.ui.cursorMode === \"minus\") ||\n        (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        return null;\n      }\n\n      return {\n        x: d3.mouse(this)[0],\n        y: d3.mouse(this)[1]\n      };\n    };\n  },\n\n  drag() {\n    const _this = this.context;\n    const self = this;\n\n    return {\n      start(d, i) {\n        /*\n         * Do not drag if the Ctrl key, Meta key, or plus cursor mode is\n         * not enabled. Also do not drag if zoom-pinching on touchmove\n         * events.\n         */\n        //   if(!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||\n        //          _this.ui.cursorMode === \"plus\") ||\n        //          (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //          (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //         return;\n        //     }\n\n        // self.dragLock = true;\n        this.origin = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        _this.zoomRect.classed(\"vzb-invisible\", false);\n      },\n\n      go(d, i) {\n        /*\n         * Cancel drag if drag lock is false, or when zoom-pinching via\n         * touchmove events.\n         */\n        // if (!self.dragLock || (d3.event.sourceEvent.type === \"touchmove\" || d3.event.sourceEvent.type === \"touchstart\") &&\n        //             (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n\n        //   _this.zoomRect\n        //     .attr(\"width\", 0)\n        //     .attr(\"height\", 0)\n        //     .classed(\"vzb-invisible\", true);\n\n        //   return;\n        // }\n\n        const origin = this.origin;\n        const mouse = {\n          x: d3.event.x,\n          y: d3.event.y\n        };\n\n        _this.zoomRect\n          .attr(\"x\", Math.min(mouse.x, origin.x))\n          .attr(\"y\", Math.min(mouse.y, origin.y))\n          .attr(\"width\", Math.abs(mouse.x - origin.x))\n          .attr(\"height\", Math.abs(mouse.y - origin.y));\n      },\n\n      stop(e) {\n        // if (!self.dragLock) return;\n        // self.dragLock = false;\n\n        _this.zoomRect\n          .attr(\"width\", 0)\n          .attr(\"height\", 0)\n          .classed(\"vzb-invisible\", true);\n\n        this.target = {\n          x: d3.mouse(this)[0],\n          y: d3.mouse(this)[1]\n        };\n        if (Math.abs(this.origin.x - this.target.x) < 10 || Math.abs(this.origin.y - this.target.y) < 10) return;\n\n        /*\n         * Only compensate for dragging when the Ctrl key or Meta key\n         * are pressed, or if the cursorMode is not in plus mode.\n         */\n        const compensateDragging = d3.event.sourceEvent.ctrlKey ||\n          d3.event.sourceEvent.metaKey ||\n          _this.ui.cursorMode === \"plus\";\n\n        self._zoomOnRectangle(\n          d3.select(this),\n          this.origin.x,\n          this.origin.y,\n          this.target.x,\n          this.target.y,\n          compensateDragging, 500\n        );\n      }\n    };\n  },\n  zoomFilter() {\n    const _this = this.context;\n    const self = this;\n\n    return function(d) {\n      const event = d3.event;\n\n      if (event.ctrlKey || event.metaKey) return false;\n\n      // Cancel drag lock when zoom-pinching via touchmove events.\n      if ((event.type === \"touchmove\" || event.type === \"touchstart\") &&\n        (event.touches.length > 1 || event.targetTouches.length > 1)) return true;\n\n      if ((event.type === \"wheel\" || event.type === \"mousewheel\") &&\n        _this.ui.zoomOnScrolling) {\n        // if (_this.scrollableAncestor) {\n        //   _this.scrollableAncestor.scrollTop -= (event.deltaY || -event.wheelDelta);\n        // }\n        // d3.event.scale = null;\n        //zoomer.scale(this.savedScale);\n        return true;\n      }\n\n      if ((event.type === \"mousedown\" || event.type === \"touchstart\") &&\n        (_this.ui.cursorMode !== \"plus\") && (_this.ui.cursorMode !== \"minus\") &&\n        (_this.ui.panWithArrow || _this.ui.cursorMode === \"hand\")) return true;\n\n      return false;\n    };\n  },\n  zoom() {\n    const _this = this.context;\n    const zoomer = this.zoomer;\n    const self = this;\n\n    return {\n      start() {\n        //this.savedScale = zoomer.scale;\n        if ((_this.ui.cursorMode !== \"plus\") && (_this.ui.cursorMode !== \"minus\")) {\n          _this.chartSvg.classed(\"vzb-zooming\", true);\n        }\n\n        _this.model._data.marker.clearHighlighted();\n        _this._setTooltip();\n\n      },\n      go() {\n\n        const sourceEvent = d3.event.sourceEvent;\n\n        //if (sourceEvent != null && (sourceEvent.ctrlKey || sourceEvent.metaKey)) return;\n\n        // Cancel drag lock when zoom-pinching via touchmove events.\n        // if (sourceEvent !== null &&\n        //             (sourceEvent.type === \"touchmove\" || sourceEvent.type === \"touchstart\") &&\n        //             (sourceEvent.touches.length > 1 || sourceEvent.targetTouches.length > 1)) {\n        //   self.dragLock = false;\n        // }\n\n        //if (self.dragLock) return;\n\n        //send the event to the page if fully zoomed our or page not scrolled into view\n//\n//                    if(d3.event.scale == 1)\n//\n//                    if(utils.getViewportPosition(_this.element.node()).y < 0 && d3.event.scale > 1) {\n//                        _this.scrollableAncestor.scrollTop += d3.event.sourceEvent.deltaY;\n//                        return;\n//                    }\n        /*\n         * Do not zoom on the chart if the scroll event is a wheel\n         * scroll. Instead, redirect the scroll event to the scrollable\n         * ancestor\n         */\n        // if (sourceEvent != null && (sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") &&\n        //             !_this.ui.zoomOnScrolling) {\n        //   if (_this.scrollableAncestor) {\n        //     _this.scrollableAncestor.scrollTop += (sourceEvent.deltaY || -sourceEvent.wheelDelta);\n        //   }\n        //   d3.event.scale = null;\n        //             //zoomer.scale(this.savedScale);\n        //   this.quitZoom = true;\n        //   return;\n        // }\n        // this.quitZoom = false;\n\n        //_this.model._data.marker.clearHighlighted();\n        //_this._setTooltip();\n\n        //var transform = d3.zoomTransform(self.zoomSelection.node())\n        //  .translate(, )\n        //.scale(d3.event.transform.k);\n        let zoom = d3.event.transform.k;\n\n        let pan = [d3.event.transform.x, d3.event.transform.y];//d3.event.translate;\n        let ratioY = zoomer.ratioY;\n        let ratioX = zoomer.ratioX;\n\n        _this.draggingNow = true;\n\n        //value protections and fallbacks\n        if (isNaN(zoom) || zoom == null) zoom = zoomer.scale;\n        if (isNaN(zoom) || zoom == null) zoom = 1;\n\n        //TODO: this is a patch to fix #221. A proper code review of zoom and zoomOnRectangle logic is needed\n        /*\n         * Mouse wheel and touchmove events set the zoom value\n         * independently of axis ratios. If the zoom event was triggered\n         * by a mouse wheel event scrolling down or touchmove event with\n         * more than 1 contact that sets zoom to 1, then set the axis\n         * ratios to 1 as well, which will fully zoom out.\n         */\n        if (zoom === 1 && sourceEvent !== null &&\n          ((sourceEvent.type === \"wheel\" || sourceEvent.type === \"mousewheel\") && (sourceEvent.deltaY || -sourceEvent.wheelDelta) > 0 ||\n          sourceEvent.type === \"touchmove\" && sourceEvent.touches.length > 1)) {\n          zoomer.ratioX = 1;\n          ratioX = 1;\n          zoomer.ratioY = 1;\n          ratioY = 1;\n        }\n\n//                if(isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = zoomer.translate();\n        if (isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = [0, 0];\n\n        // limit the zooming, so that it never goes below min value of zoom for any of the axes\n        const minZoomScale = zoomer.scaleExtent()[0];\n        if (zoom * ratioY < minZoomScale) {\n          ratioY = minZoomScale / zoom;\n          zoomer.ratioY = ratioY;\n        }\n        if (zoom * ratioX < minZoomScale) {\n          ratioX = minZoomScale / zoom;\n          zoomer.ratioX = ratioX;\n        }\n\n        const zoomXOut = zoom * ratioX < 1;\n        const zoomYOut = zoom * ratioY < 1;\n\n        //limit the panning, so that we are never outside the possible range\n        if (!zoomXOut) {\n          if (pan[0] > 0) pan[0] = 0;\n          if (pan[0] < (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        } else {\n          if (pan[0] < 0) pan[0] = 0;\n          if (pan[0] > (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;\n        }\n\n        if (!zoomYOut) {\n          if (pan[1] > 0) pan[1] = 0;\n          if (pan[1] < (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        } else {\n          if (pan[1] < 0) pan[1] = 0;\n          if (pan[1] > (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;\n        }\n\n        //limit zoom translate\n        self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        const xPanOffset = _this.width * zoom * ratioX;\n        const yPanOffset = _this.height * zoom * ratioY;\n\n        const xRange = [0 * zoom * ratioX + pan[0], xPanOffset + pan[0]];\n        const yRange = [yPanOffset + pan[1], 0 * zoom * ratioY + pan[1]];\n\n        const xRangeBumped = _this._rangeBump(xRange);\n        const yRangeBumped = _this._rangeBump(yRange);\n\n        /*\n         * Shift xRange and yRange by the difference between the bumped\n         * ranges, which is scaled by the zoom factor. This accounts for\n         * the range bump, which controls a gutter around the\n         * bubblechart, while correctly zooming.\n         */\n        const xRangeMinOffset = (xRangeBumped[0] - xRange[0]) * zoom * ratioX;\n        const xRangeMaxOffset = (xRangeBumped[1] - xRange[1]) * zoom * ratioX;\n\n        const yRangeMinOffset = (yRangeBumped[0] - yRange[0]) * zoom * ratioY;\n        const yRangeMaxOffset = (yRangeBumped[1] - yRange[1]) * zoom * ratioY;\n\n        xRange[0] += xRangeMinOffset;\n        xRange[1] += xRangeMaxOffset;\n\n        yRange[0] += yRangeMinOffset;\n        yRange[1] += yRangeMaxOffset;\n\n        // Calculate the maximum xRange and yRange available.\n        const xRangeBounds = [0, _this.width];\n        const yRangeBounds = [_this.height, 0];\n\n        const xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n        const yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n        /*\n         * Set the pan to account for the range bump by subtracting\n         * offsets and preventing panning past the range bump gutter.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] < xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;\n          if (xRange[1] > xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] > yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;\n          if (yRange[1] < yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;\n        }\n\n        //zoomer.translate = pan;\n        //self.zoomSelection.property(\"__zoom\", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n\n        /*\n         * Clamp the xRange and yRange by the amount that the bounds\n         * that are range bumped.\n         *\n         * Additionally, take the amount clamped on the end of the range\n         * and either subtract or add it to the range's other end. This\n         * prevents visible stretching of the range when only panning.\n         */\n        if (!zoomXOut) {\n          if (xRange[0] > xRangeBoundsBumped[0]) {\n            xRange[1] -= Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] < xRangeBoundsBumped[1]) {\n            xRange[0] += Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        } else {\n          if (xRange[0] < xRangeBoundsBumped[0]) {\n            xRange[1] += Math.abs(xRange[0] - xRangeBoundsBumped[0]);\n            xRange[0] = xRangeBoundsBumped[0];\n          }\n\n          if (xRange[1] > xRangeBoundsBumped[1]) {\n            xRange[0] -= Math.abs(xRange[1] - xRangeBoundsBumped[1]);\n            xRange[1] = xRangeBoundsBumped[1];\n          }\n        }\n\n        if (!zoomYOut) {\n          if (yRange[0] < yRangeBoundsBumped[0]) {\n            yRange[1] += Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] > yRangeBoundsBumped[1]) {\n            yRange[0] -= Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        } else {\n          if (yRange[0] > yRangeBoundsBumped[0]) {\n            yRange[1] -= Math.abs(yRange[0] - yRangeBoundsBumped[0]);\n            yRange[0] = yRangeBoundsBumped[0];\n          }\n\n          if (yRange[1] < yRangeBoundsBumped[1]) {\n            yRange[0] += Math.abs(yRange[1] - yRangeBoundsBumped[1]);\n            yRange[1] = yRangeBoundsBumped[1];\n          }\n        }\n\n        if (_this.model.marker.axis_x.scaleType === \"ordinal\") {\n          _this.xScale.rangeBands(xRange);\n        } else {\n          _this.xScale.range(xRange);\n        }\n\n        if (_this.model.marker.axis_y.scaleType === \"ordinal\") {\n          _this.yScale.rangeBands(yRange);\n        } else {\n          _this.yScale.range(yRange);\n        }\n\n        const formatter = function(n) {\n          return utils.isDate(n) ? n : d3.round(n, 2);\n        };\n\n        const zoomedXRange = xRangeBoundsBumped;\n        const zoomedYRange = yRangeBoundsBumped;\n\n        /*\n         * Set the zoomed min/max to the correct value depending on if the\n         * min/max values lie within the range bound regions.\n         */\n        /*\n         if(!zoomXOut) {\n         zoomedXRange[0] = xRangeBounds[0] > xRange[0] ? xRangeBounds[0] : xRange[0];\n         zoomedXRange[1] = xRangeBounds[1] < xRange[1] ? xRangeBounds[1] : xRange[1];\n         }\n\n         if(!zoomYOut) {\n         zoomedYRange[0] = yRangeBounds[0] < yRange[0] ? yRangeBounds[0] : yRange[0];\n         zoomedYRange[1] = yRangeBounds[1] > yRange[1] ? yRangeBounds[1] : yRange[1];\n         }\n         */\n\n        _this._zoomedXYMinMax = {\n          axis_x: {\n            zoomedMin: formatter(_this.xScale.invert(zoomedXRange[0])),\n            zoomedMax: formatter(_this.xScale.invert(zoomedXRange[1]))\n          },\n          axis_y: {\n            zoomedMin: formatter(_this.yScale.invert(zoomedYRange[0])),\n            zoomedMax: formatter(_this.yScale.invert(zoomedYRange[1]))\n          }\n        };\n\n\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, null, false /*avoid storing it in URL*/);\n\n        const optionsY = _this.yAxis.labelerOptions();\n        const optionsX = _this.xAxis.labelerOptions();\n        optionsY.limitMaxTickNumber = zoom * ratioY < 1.5 ? 8 : zoom * ratioY * 8;\n        optionsX.limitMaxTickNumber = zoom * ratioX < 1.5 ? 8 : zoom * ratioX * 8;\n        optionsY.transitionDuration = zoomer.duration;\n        optionsX.transitionDuration = zoomer.duration;\n\n        _this.xAxisEl.call(_this.xAxis.labelerOptions(optionsX));\n        _this.yAxisEl.call(_this.yAxis.labelerOptions(optionsY));\n        _this.redrawDataPoints(zoomer.duration);\n        _this._trails.run(\"resize\", null, zoomer.duration);\n\n        zoomer.duration = 0;\n      },\n\n      stop() {\n        _this.chartSvg.classed(\"vzb-zooming\", false);\n\n        _this.draggingNow = false;\n\n        // if (this.quitZoom) return;\n\n        //Force the update of the URL and history, with the same values\n        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, true, true);\n        zoomer.dontFeedToState = null;\n      }\n    };\n  },\n\n  expandCanvas(duration) {\n    const _this = this.context;\n    if (!duration) duration = _this.duration;\n\n    //d3 extent returns min and max of the input array as [min, max]\n    const mmX = d3.extent(utils.values(_this.frame.axis_x));\n    const mmY = d3.extent(utils.values(_this.frame.axis_y));\n\n    //protection agains unreasonable min-max results -- abort function\n    if (!mmX[0] && mmX[0] !== 0 || !mmX[1] && mmX[1] !== 0 || !mmY[0] && mmY[0] !== 0 || !mmY[1] && mmY[1] !== 0) {\n      return utils.warn(\"panZoom.expandCanvas: X or Y min/max are broken. Aborting with no action\");\n    }\n    /*\n     * Use a range bumped scale to correctly accommodate the range bump\n     * gutter.\n     */\n    const suggestedFrame = {\n      x1: _this.xScale(mmX[0]),\n      y1: _this.yScale(mmY[0]),\n      x2: _this.xScale(mmX[1]),\n      y2: _this.yScale(mmY[1])\n    };\n    const xBounds = [0, _this.width];\n    const yBounds = [_this.height, 0];\n\n    // Get the current zoom frame based on the current dimensions.\n    const frame = {\n      x1: xBounds[0],\n      x2: xBounds[1],\n      y1: yBounds[0],\n      y2: yBounds[1]\n    };\n\n    const TOLERANCE = 0.0;\n\n    /*\n     * If there is no current zoom frame, or if any of the suggested frame\n     * points extend outside of the current zoom frame, then expand the\n     * canvas.\n     */\n    if (!_this.isCanvasPreviouslyExpanded ||\n      suggestedFrame.x1 < frame.x1 * (1 - TOLERANCE) || suggestedFrame.x2 > frame.x2 * (1 + TOLERANCE) ||\n      suggestedFrame.y2 < frame.y2 * (1 - TOLERANCE) || suggestedFrame.y1 > frame.y1 * (1 + TOLERANCE)) {\n      /*\n       * If there is already a zoom frame, then clamp the suggested frame\n       * points to only zoom out and expand the canvas.\n       *\n       * If any of x1, x2, y1, or y2 is within the current frame\n       * boundaries, then clamp them to the frame boundaries. If any of\n       * the above values will translate into a data value that is outside\n       * of the possible data range, then clamp them to the frame\n       * coordinate that corresponds to the maximum data value that can\n       * be displayed.\n       */\n      if (_this.isCanvasPreviouslyExpanded) {\n        /*\n         * Calculate bounds and bumped scale for calculating the data boundaries\n         * to which the suggested frame points need to be clamped.\n         */\n        const xBoundsBumped = _this._rangeBump(xBounds);\n        const yBoundsBumped = _this._rangeBump(yBounds);\n\n        if (suggestedFrame.x1 > xBoundsBumped[0]) suggestedFrame.x1 = xBoundsBumped[0];\n        if (suggestedFrame.x2 < xBoundsBumped[1]) suggestedFrame.x2 = xBoundsBumped[1];\n        if (suggestedFrame.y1 < yBoundsBumped[0]) suggestedFrame.y1 = yBoundsBumped[0];\n        if (suggestedFrame.y2 > yBoundsBumped[0]) suggestedFrame.y2 = yBoundsBumped[1];\n      }\n\n      _this.isCanvasPreviouslyExpanded = true;\n      this._zoomOnRectangle(_this.element, suggestedFrame.x1, suggestedFrame.y1,\n        suggestedFrame.x2, suggestedFrame.y2, false, duration);\n    } else {\n      _this.redrawDataPoints(duration);\n    }\n  },\n\n  zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, duration, dontFeedToState) {\n    const _this = this.context;\n    let minX = zoomedMinX;\n    let maxX = zoomedMaxX;\n    let minY = zoomedMinY;\n    let maxY = zoomedMaxY;\n\n    const xDomain = _this.xScale.domain();\n    const yDomain = _this.yScale.domain();\n\n    /*\n     * Prevent zoomout if only one of zoom edges set outside domain\n     */\n    if (minX < xDomain[0] && maxX < xDomain[1]) minX = xDomain[0];\n    if (minX > xDomain[0] && maxX > xDomain[1]) maxX = xDomain[1];\n    if (minY < yDomain[0] && maxY < yDomain[1]) minY = yDomain[0];\n    if (minY > yDomain[0] && maxY > yDomain[1]) maxY = yDomain[1];\n\n\n    const xRange = [_this.xScale(minX), _this.xScale(maxX)];\n    const yRange = [_this.yScale(minY), _this.yScale(maxY)];\n\n\n    this._zoomOnRectangle(_this.element, xRange[0], yRange[0], xRange[1], yRange[1], false, duration, dontFeedToState);\n  },\n\n  _zoomOnRectangle(element, zoomedX1, zoomedY1, zoomedX2, zoomedY2, compensateDragging, duration, dontFeedToState) {\n    const _this = this.context;\n    const zoomer = this.zoomer;\n    const transform = d3.zoomTransform(this.zoomSelection.node());\n\n    const x1 = zoomedX1;\n    const y1 = zoomedY1;\n    const x2 = zoomedX2;\n    const y2 = zoomedY2;\n\n    /*\n     * When dragging to draw a rectangle, the translate vector has (x2 - x1)\n     * added to zoomer.translate()[0], and (y2 - 1) added to\n     * zoomer.translate()[1].\n     *\n     * We need to compensate for this addition when\n     * zooming with a rectangle, because zooming with a rectangle will\n     * update the translate vector with new values based on the rectangle\n     * dimensions.\n     */\n    if (compensateDragging) {\n      transform.translate(\n        x1 - x2,\n        y1 - y2\n      );\n      // zoomer.translate([\n      //     zoomer.translate()[0] + x1 - x2,\n      //     zoomer.translate()[1] + y1 - y2\n      // ]);\n    }\n\n    const xRangeBounds = [0, _this.width];\n    const yRangeBounds = [_this.height, 0];\n\n    const xRangeBoundsBumped = _this._rangeBump(xRangeBounds);\n    const yRangeBoundsBumped = _this._rangeBump(yRangeBounds);\n\n    const minZoom = zoomer.scaleExtent()[0];\n    const maxZoom = zoomer.scaleExtent()[1];\n    let zoom, ratioX, ratioY;\n\n    if (x1 == x2 || y1 == y2 || xRangeBoundsBumped[0] == xRangeBoundsBumped[1] || yRangeBoundsBumped[0] == yRangeBoundsBumped[1]) {\n      return utils.warn(\"_zoomOnRectangle(): can not proceed because this may result in infinity zooms\");\n    }\n\n    if (Math.abs(x1 - x2) > Math.abs(y1 - y2)) {\n      zoom = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioY *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioX = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k / zoom * zoomer.ratioX;\n      ratioY = zoomer.ratioY;\n    } else {\n      zoom = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k;\n\n      /*\n       * Clamp the zoom scalar to the maximum zoom allowed before\n       * calculating the next ratioX and ratioY.\n       */\n      if (zoom < minZoom) {\n        zoomer.ratioX *= zoom / transform.k;\n        zoom = minZoom;\n      }\n      if (zoom > maxZoom) zoom = maxZoom;\n\n      ratioY = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k / zoom * zoomer.ratioY;\n      ratioX = zoomer.ratioX;\n    }\n\n    const pan = [\n      (transform.x - Math.min(x1, x2)) / transform.k / zoomer.ratioX * zoom * ratioX + (xRangeBoundsBumped[0] - xRangeBounds[0]),\n      (transform.y - Math.min(y1, y2)) / transform.k / zoomer.ratioY * zoom * ratioY + (yRangeBoundsBumped[1] - yRangeBounds[1])\n    ];\n\n    zoomer.dontFeedToState = dontFeedToState;\n    //zoomer.scale(zoom);\n    zoomer.ratioY = ratioY || 1; //NaN defaults to 1\n    zoomer.ratioX = ratioX || 1; //NaN defaults to 1\n    //zoomer.translate(pan);\n    zoomer.duration = duration ? duration : 0;\n\n    //zoomer.event(element);\n    this.zoomSelection.call(zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));\n  },\n\n  /*\n   * Incrementally zoom in or out and pan the view so that it never looses the point where click happened\n   * this function is a modified d3's own zoom behavior on double click\n   * for the original code see https://github.com/mbostock/d3/blob/master/src/behavior/zoom.js\n   * function dblclicked() and what it refers to\n   */\n  zoomByIncrement(direction, duration) {\n    const _this = this.context;\n    const transform = d3.zoomTransform(this.zoomSelection.node());\n\n    let ratio = transform.k;\n    const pan = [transform.x, transform.y];\n\n    const mouse = d3.mouse(this.zoomSelection.node());\n    let k = Math.log(ratio) / Math.LN2;\n\n    //change factor direction based on the input. default is no direction supplied\n    if (direction == \"plus\" || !direction) k = Math.floor(k) + 1;\n    if (direction == \"minus\") k = Math.ceil(k) - 1;\n\n    //decode panning\n    let locus = [(mouse[0] - pan[0]) / ratio, (mouse[1] - pan[1]) / ratio];\n\n    //recalculate zoom ratio\n    const scaleExtent = this.zoomer.scaleExtent();\n    if (ratio == scaleExtent[0]) {\n      this.zoomer.ratioY = 1;\n      this.zoomer.ratioX = 1;\n    }\n    ratio = Math.max(scaleExtent[0], Math.min(scaleExtent[1], Math.pow(2, k)));\n\n    //recalculate panning\n    locus = [locus[0] * ratio + pan[0], locus[1] * ratio + pan[1]];\n    pan[0] += mouse[0] - locus[0];\n    pan[1] += mouse[1] - locus[1];\n\n    //save changes to the zoom behavior and run the event\n    //this.zoomer.scale(ratio);\n    //this.zoomer.translate([pan[0], pan[1]]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(_this.element);\n    this.zoomSelection.call(this.zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(ratio));\n\n  },\n\n\n  /*\n   * Reset zoom values without triggering a zoom event.\n   */\n  resetZoomState(element) {\n    //this.zoomer.scaleTo(element, 1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    (element || this.zoomSelection).property(\"__zoom\", d3.zoomIdentity);\n  },\n\n  reset(element, duration) {\n    const _this = this.context;\n    _this.isCanvasPreviouslyExpanded = false;\n\n    //this.zoomer.scale(1);\n    this.zoomer.ratioY = 1;\n    this.zoomer.ratioX = 1;\n    //this.zoomer.translate([0, 0]);\n    this.zoomer.duration = duration || 0;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.transform, d3.zoomIdentity);\n  },\n\n  rerun(element) {\n    const _this = this.context;\n    //this.zoomer.event(element || _this.element);\n    (element || this.zoomSelection).call(this.zoomer.scaleBy, 1);\n  },\n\n  zoomSelection(element) {\n    this.zoomSelection = element;\n  }\n\n});\n\nexport default PanZoom;\n\n\n// WEBPACK FOOTER //\n// ./src/panzoom.js","\nimport cssEscape from \"css.escape\";\n\nconst { utils } = Vizabi;\n\nconst Trail = Vizabi.Class.extend({\n\n  init(context) {\n    this.context = context;\n    this._isCreated = null;\n    this.actionsQueue = {};\n    this.entityTrails = {};\n    this.trailsData = [];\n    this.trailsInProgress = {};\n    this.activePromises = {};\n    this.trailTransitions = {};\n    this.delayedIterations = {};\n    this.drawingQueue = {};\n  },\n\n  toggle(arg) {\n    const _context = this.context;\n    if (arg) {\n\n      _context._trails.create().then(() => {\n        _context._trails.run([\"findVisible\", \"reveal\", \"opacityHandler\"]);\n      });\n    } else {\n      _context._trails.run(\"remove\");\n      _context.model.marker.select.forEach(d => {\n        d.trailStartTime = null;\n      });\n    }\n  },\n\n  create(selection) {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n    const TIMEDIM = _context.TIMEDIM;\n    this._isCreated = new Promise((resolve, reject) => {\n      //quit if the function is called accidentally\n      if (!_context.model.ui.chart.trails) return;\n\n      const timePoints = _context.model.time.getAllSteps();\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      const promises = [];\n      selection = selection == null ? _context.model.marker.select : [selection];\n      _this._clearActions(selection);\n      _this.trailsData = _context.model.marker.select.map(d => {\n        const r = {\n          status: \"created\",\n          selectedEntityData: d\n        };\n        r[KEY] = d[KEY];\n        return r;\n      });\n      _this.trailTransitions = {};\n      const _trails = _context.bubbleContainer.selectAll(\"g.vzb-bc-entity.entity-trail\")\n        .data(_this.trailsData, d => (d[KEY]));\n\n      _trails.exit().remove();\n      _trails.enter()\n        .insert(\"g\", function(d) {\n          return this.querySelector(\".bubble-\" + cssEscape(d[KEY]));\n        })\n        .attr(\"class\", d => \"vzb-bc-entity entity-trail trail-\" + d[KEY])\n        .merge(_trails)\n        .each(function(d, index) {\n          // used for prevent move trail start time forward when we have empty values at end of time range\n          const trail = this;\n          promises.push(new Promise((resolve, reject) => {\n            const trailSegmentData = timePoints.map(m => ({\n              t: m,\n              key: d[KEY]\n            }));\n            const entityTrails = d3.select(trail).selectAll(\"g\")\n              .data(trailSegmentData)\n              .classed(\"vzb-invisible\", true);\n\n            entityTrails.exit().remove();\n\n            _this.entityTrails[d[KEY]] = entityTrails.enter().append(\"g\")\n              .attr(\"class\", \"vzb-bc-trailsegment\")\n              .on(\"mouseover\", function(segment, index) {\n                if (utils.isTouchDevice()) return;\n\n                const pointer = {};\n                pointer[KEY] = segment.key;\n                pointer[TIMEDIM] = segment.t;\n\n                _context._axisProjections(pointer);\n                _context._labels.highlight(d, true);\n                const text = _context.model.time.formatDate(segment.t);\n                const selectedData = utils.find(_context.model.marker.select, f => f[KEY] == d[KEY]);\n                _context.model.marker.getFrame(pointer[TIMEDIM], values => {\n                  const x = _context.xScale(values.axis_x[pointer[KEY]]);\n                  const y = _context.yScale(values.axis_y[pointer[KEY]]);\n                  const s = utils.areaToRadius(_context.sScale(values.size[pointer[KEY]]));\n                  const c = values.color[pointer[KEY]] != null ? _context.cScale(values.color[pointer[KEY]]) : _context.COLOR_WHITEISH;\n                  if (text !== selectedData.trailStartTime) {\n                    _context._setTooltip(text, x, y, s + 3, c);\n                  }\n                  _context._setBubbleCrown(x, y, s, c);\n                  _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", {\n                    \"size\": values.size[pointer[KEY]],\n                    \"color\": values.color[pointer[KEY]]\n                  });\n                });\n                //change opacity to OPACITY_HIGHLT = 1.0;\n                d3.select(this).style(\"opacity\", 1.0);\n              })\n              .on(\"mouseout\", function(segment, index) {\n                if (utils.isTouchDevice()) return;\n                _context._axisProjections();\n                _context._setTooltip();\n                _context._setBubbleCrown();\n                _context._labels.highlight(null, false);\n                _context.model.marker.getModelObject(\"highlight\").trigger(\"change\", null);\n                d3.select(this).style(\"opacity\", _context.model.marker.opacityRegular);\n              })\n              .each(function(segment, index) {\n                const view = d3.select(this);\n                view.append(\"circle\");\n                view.append(\"line\");\n              })\n              .merge(entityTrails);\n            resolve();\n          }));\n        });\n      if (promises.length > 0) {\n        Promise.all(promises).then(segments => {\n          resolve(true);\n        });\n      } else {\n        resolve(true);\n      }\n    });\n    return this._isCreated;\n  },\n\n  /**\n   * add actions for each selected entities\n   * @param selections\n   * @param actions\n   * @private\n   */\n  _addActions(selections, actions) {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n\n    selections.forEach(d => {\n      if (!_this.actionsQueue[d[KEY]]) _this.actionsQueue[d[KEY]] = [];\n      _this.actionsQueue[d[KEY]] = [].concat(_this.actionsQueue[d[KEY]].filter(value => actions.indexOf(value) == -1), actions);\n    });\n  },\n\n  _clearActions(selections) {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n\n    selections.forEach(d => {\n      if (!_this.actionsQueue[d[KEY]]) _this.actionsQueue[d[KEY]] = [];\n      _this.actionsQueue[d[KEY]] = [];\n      _this.drawingQueue[d[KEY]] = {};\n      _this.delayedIterations[d[KEY]] = {};\n      if (!_this.activePromises[d[KEY]]) _this.activePromises[d[KEY]] = [];\n      utils.forEach(_this.activePromises[d[KEY]], (promise, key) => {\n        if (promise.status === \"pending\") promise.reject();\n      });\n      _this.trailsInProgress[d[KEY]] = null;\n      _this.activePromises[d[KEY]] = [];\n    });\n  },\n\n  _getNextAction(key) {\n    return this.actionsQueue[key].shift();\n  },\n\n  run(actions, selection, duration) {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n    if (!this._isCreated || _context.model.time.splash) return;\n    if (typeof actions === \"string\") actions = [actions];\n\n    this._isCreated.then(() => {\n      //quit if function is called accidentally\n      if ((!_context.model.ui.chart.trails || !_context.model.marker.select.length) && actions != \"remove\") return;\n\n      if (!duration) duration = 0;\n\n      //work with marker.select (all selected entities), if no particular selection is specified\n      selection = selection == null ? _context.model.marker.select : [selection];\n      for (let i = 0; i < actions.length; i++) {\n        if ([\"resize\", \"recolor\", \"remove\"].indexOf(actions[i]) != -1) {\n          const action = actions.splice(i, 1).pop();\n          --i;\n          _this.trailsData.forEach(d => {\n            const trail = _this.entityTrails[d[KEY]];\n            _context._trails[\"_\" + action](trail, duration, d);\n          });\n        }\n      }\n      if (actions.length == 0) {\n        return;\n      }\n      _this._addActions(selection, actions);\n      _this.trailsData.forEach(d => {\n        if (actions.indexOf(\"findVisible\") != -1) {\n          _this.drawingQueue[d[KEY]] = {};\n          _this.delayedIterations[d[KEY]] = {};\n        }\n        const trail = _this.entityTrails[d[KEY]];\n        //do all the actions over \"trail\"\n        const executeSequential = function(index) { // some function can be async, but we should run next when previous completed\n          const action = _this._getNextAction(d[KEY]);\n          if (action) {\n            _this.trailsInProgress[d[KEY]] = action;\n            const response = _context._trails[\"_\" + action](trail, duration, d);\n            if (response && response instanceof Promise) {\n              response.then(() => {\n                _this.trailsInProgress[d[KEY]] = null;\n                executeSequential(index + 1);\n              }, () => {\n                _this.trailsInProgress[d[KEY]] = null;\n              });\n            } else {\n              _this.trailsInProgress[d[KEY]] = null;\n              executeSequential(index + 1);\n            }\n          }\n        };\n        if (!_this.trailsInProgress[d[KEY]]) {\n          executeSequential(0);\n        }\n      });\n    });\n\n  },\n\n\n  _remove(trail, duration, d) {\n    this.actionsQueue[d[this.context.KEY]] = [];\n    if (trail) { // TODO: in some reason run twice\n      d3.select(this.entityTrails[d[this.context.KEY]].node().parentNode).remove();\n      this.entityTrails[d[this.context.KEY]] = null;\n    }\n  },\n\n  _resize(trail, duration, d) {\n    const _context = this.context;\n    if (_context.model.time.splash) {\n      return;\n    }\n//    this._isCreated.then(function() {\n    let updateLabel = false;\n\n    trail.each(function(segment, index) {\n\n      if (segment.valueY == null || segment.valueX == null || segment.valueS == null) return;\n\n      const view = d3.select(this);\n      if (duration) {\n        view.select(\"circle\")\n          .transition().duration(duration).ease(d3.easeLinear)\n          .attr(\"cy\", _context.yScale(segment.valueY))\n          .attr(\"cx\", _context.xScale(segment.valueX))\n          .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"circle\").interrupt()\n          .attr(\"cy\", _context.yScale(segment.valueY))\n          .attr(\"cx\", _context.xScale(segment.valueX))\n          .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)))\n          .transition();\n      }\n\n      if (!updateLabel && !segment.transparent) {\n        updateLabel = true;\n        _context._labels.updateLabelOnlyPosition(d, null, { \"scaledS0\": utils.areaToRadius(_context.sScale(segment.valueS)) });\n      }\n\n      if (!segment.next) return;\n      const next = segment.next;\n      if (next == null) return;\n      if (next.valueY == null || next.valueX == null) return;\n\n      const lineLength = Math.sqrt(\n        Math.pow(_context.xScale(segment.valueX) - _context.xScale(next.valueX), 2) +\n        Math.pow(_context.yScale(segment.valueY) - _context.yScale(next.valueY), 2)\n      );\n      if (duration) {\n        view.select(\"line\")\n          .transition().duration(duration).ease(d3.easeLinear)\n          .attr(\"x1\", _context.xScale(next.valueX))\n          .attr(\"y1\", _context.yScale(next.valueY))\n          .attr(\"x2\", _context.xScale(segment.valueX))\n          .attr(\"y2\", _context.yScale(segment.valueY))\n          .attr(\"stroke-dasharray\", lineLength)\n          .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)));\n      } else {\n        view.select(\"line\").interrupt()\n          .attr(\"x1\", _context.xScale(next.valueX))\n          .attr(\"y1\", _context.yScale(next.valueY))\n          .attr(\"x2\", _context.xScale(segment.valueX))\n          .attr(\"y2\", _context.yScale(segment.valueY))\n          .attr(\"stroke-dasharray\", lineLength)\n          .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)))\n          .transition();\n      }\n    });\n  },\n\n  _recolor(trail, duration, d) {\n    const _context = this.context;\n\n    trail.each(function(segment, index) {\n\n      const view = d3.select(this);\n\n      const strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n        //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n        _context.model.marker.color.getColorShade({\n          colorID: segment.valueC,\n          shadeID: \"shade\"\n        })\n        :\n        //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n        (segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH);\n\n      view.select(\"circle\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n        .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n      view.select(\"line\")\n      //.transition().duration(duration).ease(d3.easeLinear)\n        .style(\"stroke\", strokeColor);\n    });\n  },\n\n  _opacityHandler(trail, duration, d) {\n    const _context = this.context;\n\n    trail.each(function(segment, index) {\n\n      const view = d3.select(this);\n\n      view\n      //.transition().duration(duration).ease(d3.easeLinear)\n        .style(\"opacity\", d.opacity || _context.model.marker.opacityRegular);\n    });\n  },\n\n\n  _findVisible(trail, duration, d) {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n    return new Promise((resolve, reject) => {\n      new Promise((resolve1, reject1) => {\n        if (!d.limits) {\n          _context.model.marker.getEntityLimits(d[KEY]).then(limits => {\n            d.limits = limits;\n            resolve1();\n          });\n        } else {\n          resolve1();\n        }\n      }).then(() => {\n        if (!d.selectedEntityData.trailStartTime) {\n          d.selectedEntityData.trailStartTime = _context.model.time.formatDate(_context.time);\n        }\n        let trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n        if (_context.time - trailStartTime < 0 || d.limits.min - trailStartTime > 0) {\n          if (_context.time - trailStartTime < 0) {\n            // move trail start time with trail label back if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d3.max([_context.time, d.limits.min]));\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          } else {\n            // move trail start time with trail label to start time if need\n            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d.limits.min);\n            trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n          }\n          const cache = _context._labels.cached[d[KEY]];\n          const valueS = _context.frame.size[d[KEY]];\n          const valueC = _context.frame.color[d[KEY]];\n          cache.labelX0 = _context.frame.axis_x[d[KEY]];\n          cache.labelY0 = _context.frame.axis_y[d[KEY]];\n          cache.scaledS0 = (valueS || valueS === 0) ? utils.areaToRadius(_context.sScale(valueS)) : null;\n          cache.scaledC0 = valueC != null ? _context.cScale(valueC) : _context.COLOR_WHITEISH;\n          _context._updateLabel(d, 0, _context.frame.axis_x[d[KEY]], _context.frame.axis_y[d[KEY]], _context.frame.size[d[KEY]], _context.frame.color[d[KEY]], _context.frame.label[d[KEY]], _context.frame.size_label[d[KEY]], 0, true);\n        }\n        trail.each((segment, index) => {\n          // segment is transparent if it is after current time or before trail StartTime\n          const segmentVisibility = segment.transparent;\n          segment.transparent = d.selectedEntityData.trailStartTime == null || (segment.t - _context.time > 0) || (trailStartTime - segment.t > 0)\n            //no trail segment should be visible if leading bubble is shifted backwards, beyond start time\n            || (d.selectedEntityData.trailStartTime - _context.model.time.formatDate(_context.time) >= 0);\n          // always update nearest 2 points\n          if (segmentVisibility != segment.transparent || Math.abs(_context.model.time.formatDate(segment.t) - _context.model.time.formatDate(_context.time)) < 2) segment.visibilityChanged = true; // segment changed, so need to update it\n          if (segment.transparent) {\n            d3.select(trail._groups[0][index]).classed(\"vzb-invisible\", segment.transparent);\n          }\n        });\n        _this.drawingQueue[d[KEY]] = {};\n        _this.delayedIterations[d[KEY]] = {};\n        resolve();\n      });\n    });\n  },\n\n  _abortAnimation() {\n    const _context = this.context;\n    const _this = this;\n    const KEY = _context.KEY;\n    _this.trailsData.forEach(d => {\n      if (_this.trailTransitions[d[KEY]]) {\n        _this.trailTransitions[d[KEY]].select(\"line\").interrupt().transition();\n      }\n    });\n  },\n\n  _reveal(trail, duration, d) {\n    const _context = this.context;\n    if(_context.model.time.playing) duration = _context.model.time.delay;\n    const _this = this;\n    const KEY = _context.KEY;\n    d.status = \"reveal\";\n    const trailStartTime = _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime);\n    const generateTrailSegment = function(trail, index, nextIndex, level) {\n      return new Promise((resolve, reject) => {\n        const view = d3.select(trail._groups[0][index]);\n\n        const segment = view.datum();\n\n        //console.log(d[KEY] + \" transparent: \" + segment.transparent + \" vis_changed:\" + segment.visibilityChanged);\n        if (nextIndex - index == 1) {\n          if (segment.transparent) {\n            view.classed(\"vzb-invisible\", segment.transparent);\n            return resolve();\n          } else if (!segment.visibilityChanged) { // pass segment if it is not changed\n            return resolve();\n          }\n        }\n        _context.model.marker.getFrame(segment.t, frame => {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame) return resolve();\n          segment.valueY = frame.axis_y[d[KEY]];\n          segment.valueX = frame.axis_x[d[KEY]];\n          segment.valueS = frame.size[d[KEY]];\n          segment.valueC = frame.color[d[KEY]];\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            return resolve();\n          }\n\n          // fix label position if it not in correct place\n          if (trailStartTime && trailStartTime.toString() == segment.t.toString()) {\n            const cache = _context._labels.cached[d[KEY]];\n            cache.labelX0 = segment.valueX;\n            cache.labelY0 = segment.valueY;\n            const valueS = segment.valueS;\n            cache.scaledS0 = (valueS || valueS === 0) ? utils.areaToRadius(_context.sScale(valueS)) : null;\n            cache.scaledC0 = segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH;\n            _context._updateLabel(d, index, segment.valueX, segment.valueY, segment.valueS, segment.valueC, frame.label[d[KEY]], frame.size_label[d[KEY]], 0, true);\n          }\n          view.select(\"circle\")\n          //.transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"cy\", _context.yScale(segment.valueY))\n            .attr(\"cx\", _context.xScale(segment.valueX))\n            .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)))\n            .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n          view.select(\"line\")\n            .attr(\"x2\", _context.xScale(segment.valueX))\n            .attr(\"y2\", _context.yScale(segment.valueY))\n            .attr(\"x1\", _context.xScale(segment.valueX))\n            .attr(\"y1\", _context.yScale(segment.valueY));\n\n          // last point should have data for line but it is invisible\n          if (_context.time - segment.t > 0) {\n            segment.visibilityChanged = false;\n            view.classed(\"vzb-invisible\", segment.transparent);\n          } else {\n            view.classed(\"vzb-invisible\", true);\n          }\n\n          if (!trail._groups[0][nextIndex] || _context.time.toString() == segment.t.toString()) {\n            return resolve();\n          }\n\n          const next = d3.select(trail._groups[0][nextIndex]);\n          const nextSegment = next.datum();\n          nextSegment.previous = segment;\n          segment.next = nextSegment;\n          let nextTime = nextSegment.t;\n          if (_context.time - nextSegment.t < 0) { // time is not equal start of year\n            segment.visibilityChanged = true; // redraw needed next time because line not have full length\n            nextTime = _context.time;\n          }\n          _context.model.marker.getFrame(nextTime, nextFrame => {\n            if (d.status != \"reveal\") return resolve();\n            if (!nextFrame || segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n              return resolve();\n            }\n\n            if (nextFrame.axis_x[d[KEY]] == null || nextFrame.axis_y[d[KEY]] == null) {\n              return resolve();\n            }\n\n            nextSegment.valueY = nextFrame.axis_y[d[KEY]];\n            nextSegment.valueX = nextFrame.axis_x[d[KEY]];\n            nextSegment.valueS = nextFrame.size[d[KEY]];\n            nextSegment.valueC = nextFrame.color[d[KEY]];\n\n            _this.trailTransitions[d[KEY]] = view;\n            const strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n              //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n              _context.model.marker.color.getColorShade({\n                colorID: segment.valueC,\n                shadeID: \"shade\"\n              })\n              :\n              //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n              (segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH);\n\n            const lineLength = Math.sqrt(\n              Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextFrame.axis_x[d[KEY]]), 2) +\n              Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextFrame.axis_y[d[KEY]]), 2)\n            );\n            view.select(\"line\")\n              .attr(\"stroke-dasharray\", lineLength)\n              .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)))\n              .style(\"stroke\", strokeColor)\n              .transition().duration(duration).ease(d3.easeLinear)\n              .attr(\"x1\", _context.xScale(nextSegment.valueX))\n              .attr(\"y1\", _context.yScale(nextSegment.valueY))\n              .attr(\"x2\", _context.xScale(segment.valueX))\n              .attr(\"y2\", _context.yScale(segment.valueY));\n            if (nextIndex - index > 1) {\n              addNewIntervals(index, nextIndex);\n              return resolve();\n            }\n            return resolve();\n          });\n        });\n      });\n    };\n    const addPointBetween = function(previousIndex, nextIndex, index) {\n      return new Promise((resolve, reject) => {\n        const previous = d3.select(trail._groups[0][previousIndex]);\n        const next = d3.select(trail._groups[0][nextIndex]);\n        const view = d3.select(trail._groups[0][index]);\n        const previousSegment = previous.datum();\n        const nextSegment = next.datum();\n        const segment = view.datum();\n\n        if ((!previousSegment.previous && !previousSegment.next) || (!nextSegment.previous && !nextSegment.next)) {\n          // segment data cleared by create action\n          return resolve();\n        }\n\n        _context.model.marker.getFrame(segment.t, frame => {\n          if (d.status != \"reveal\") return resolve();\n          if (!frame ||\n            (typeof frame.axis_x === \"undefined\") || frame.axis_x[d[KEY]] == null ||\n            (typeof frame.axis_y === \"undefined\") || frame.axis_y[d[KEY]] == null) {\n            utils.warn(\"Frame for trail missed: \" + segment.t);\n            return resolve();\n          }\n          segment.valueY = frame.axis_y[d[KEY]];\n          segment.valueX = frame.axis_x[d[KEY]];\n          segment.valueS = frame.size[d[KEY]];\n          segment.valueC = frame.color[d[KEY]];\n\n          segment.previous = previousSegment;\n          segment.next = nextSegment;\n          previousSegment.next = segment;\n          nextSegment.previous = segment;\n\n          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {\n            utils.warn(\"Data for trail point missed: \" + segment.t);\n            return resolve();\n          }\n\n          const strokeColor = _context.model.marker.color.which == \"geo.world_4region\" ?\n            //use predefined shades for color palette for \"geo.world_4region\" (hardcoded)\n            _context.model.marker.color.getColorShade({\n              colorID: segment.valueC,\n              shadeID: \"shade\"\n            })\n            :\n            //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)\n            (segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH);\n\n          const firstLineLength = Math.sqrt(\n            Math.pow(_context.xScale(previousSegment.valueX) - _context.xScale(segment.valueX), 2) +\n            Math.pow(_context.yScale(previousSegment.valueY) - _context.yScale(segment.valueX), 2)\n          );\n\n          previous.select(\"line\")\n            .transition().duration(duration).ease(d3.easeLinear)\n            .attr(\"x1\", _context.xScale(segment.valueX))\n            .attr(\"y1\", _context.yScale(segment.valueY))\n            .attr(\"x2\", _context.xScale(previousSegment.valueX))\n            .attr(\"y2\", _context.yScale(previousSegment.valueY))\n            .attr(\"stroke-dasharray\", firstLineLength)\n            .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(previousSegment.valueS)))\n            .style(\"stroke\", strokeColor);\n\n          view.classed(\"vzb-invisible\", segment.transparent);\n\n          if (!segment.transparent) {\n            view.select(\"circle\")\n            //.transition().duration(duration).ease(d3.easeLinear)\n              .attr(\"cy\", _context.yScale(segment.valueY))\n              .attr(\"cx\", _context.xScale(segment.valueX))\n              .attr(\"r\", utils.areaToRadius(_context.sScale(segment.valueS)))\n              .style(\"fill\", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);\n\n            const secondLineLength = Math.sqrt(\n              Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextSegment.valueX), 2) +\n              Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextSegment.valueY), 2)\n            );\n\n            view.select(\"line\")\n              .transition().duration(duration).ease(d3.easeLinear)\n              .attr(\"x1\", _context.xScale(nextSegment.valueX))\n              .attr(\"y1\", _context.yScale(nextSegment.valueY))\n              .attr(\"x2\", _context.xScale(segment.valueX))\n              .attr(\"y2\", _context.yScale(segment.valueY))\n              .attr(\"stroke-dasharray\", secondLineLength)\n              .attr(\"stroke-dashoffset\", utils.areaToRadius(_context.sScale(segment.valueS)))\n              .style(\"stroke\", strokeColor);\n          }\n          addNewIntervals(previousIndex, index, nextIndex);\n          resolve();\n        });\n      });\n    };\n    const addNewIntervals = function(previousIndex, index, nextIndex) {\n      let mediumIndex;\n      if (index - previousIndex > 1) {\n        mediumIndex = getPointBetween(previousIndex, index);\n        _this.delayedIterations[d[KEY]][previousIndex] = {\n          first: previousIndex,\n          next: index,\n          medium: mediumIndex\n        };\n      }\n      if (nextIndex && nextIndex - index > 1) {\n        mediumIndex = getPointBetween(index, nextIndex);\n        _this.delayedIterations[d[KEY]][index] = {\n          first: index,\n          next: nextIndex,\n          medium: mediumIndex\n        };\n      }\n    };\n    const getPointBetween = function(previous, next) {\n      return Math.round(previous + (next - previous) / 2);\n    };\n\n    const _generateKeys = function(d, trail, div) {\n      const response = [];\n      let min = 0, max = 0;\n      const maxValue = d3.min([d.limits.max, _context.time]);\n      const minValue = d3.max([d.limits.min, _context.model.time.parse(\"\" + d.selectedEntityData.trailStartTime)]);\n      utils.forEach(trail._groups[0], (segment, index) => {\n        const data = segment.__data__;\n        if (data.t - minValue == 0) {\n          min = index;\n        } else if (data.t - maxValue == 0) {\n          max = index;\n        } else {\n          if (data.t > minValue && data.t < maxValue) {\n            if (_context.model.time.formatDate(data.t) % div == 0 || (data.next && data.previous)) {\n              response.push(index);\n            }\n          }\n        }\n      });\n      response.unshift(min);\n      if (max > 0) {\n        response.push(max);\n      }\n      return response;\n    };\n\n    const processPoints = function() {\n      return new Promise((resolve, reject) => {\n        const processPoint = function() {\n          const pointIndex = Object.keys(_this.drawingQueue[d[KEY]])[Math.floor(Math.random() * Object.keys(_this.drawingQueue[d[KEY]]).length)];\n          const point = JSON.parse(JSON.stringify(_this.drawingQueue[d[KEY]][pointIndex]));\n          delete _this.drawingQueue[d[KEY]][pointIndex];\n          addPointBetween(point.first, point.next, point.medium).then(() => {\n            if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n              processPoint();\n            } else {\n              resolve();\n            }\n          });\n        };\n        if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {\n          processPoint(_this.drawingQueue[d[KEY]]);\n        } else {\n          resolve();\n        }\n      });\n    };\n\n    return new Promise((resolve, reject) => {\n      /**\n       * iteration for each point from first segment to last\n       * @param trail\n       * @param index\n       */\n      const generateTrails = function(trail, index) {\n        if (index < 0 || index >= trail._groups[0].length) {\n          return resolve();\n        }\n        generateTrailSegment(trail, index, index + 1).then(() => {\n          generateTrails(trail, index + 1);\n        }, () => resolve());\n      };\n\n      /**\n       * recursive iteration for drawing point between points calculated in previous step\n       */\n      const processPointsBetween = function() {\n        processPoints().then(() => {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            return resolve();\n          }\n          _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n          _this.delayedIterations[d[KEY]] = {};\n          processPointsBetween();\n        }, () => resolve());\n      };\n\n      if (_context.model.marker.framesAreReady()) {\n        generateTrails(trail, 0);\n      } else {\n        _this.delayedIterations[d[KEY]] = {};\n        _this.drawingQueue[d[KEY]] = {};\n        const trailKeys = _generateKeys(d, trail, 50);\n        const segments = [];\n        if (trailKeys.length <= 1) {\n          return resolve();\n        }\n\n        _this.delayedIterations[d[KEY]] = {};\n        for (let i = 0; i < trailKeys.length - 1; i++) {\n          segments.push(generateTrailSegment(trail, trailKeys[i], trailKeys[i + 1], 1));\n        }\n        Promise.all(segments).then(() => {\n          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {\n            resolve();\n          } else {\n            _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];\n            _this.delayedIterations[d[KEY]] = {};\n            processPointsBetween();\n          }\n        }, () => {\n          resolve();\n        });\n      }\n    });\n  }\n});\n\nexport default Trail;\n\n\n\n// WEBPACK FOOTER //\n// ./src/trail.js","/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n;(function(root, factory) {\n\t// https://github.com/umdjs/umd/blob/master/returnExports.js\n\tif (typeof exports == 'object') {\n\t\t// For Node.js.\n\t\tmodule.exports = factory(root);\n\t} else if (typeof define == 'function' && define.amd) {\n\t\t// For AMD. Register as an anonymous module.\n\t\tdefine([], factory.bind(root, root));\n\t} else {\n\t\t// For browser globals (not exposing the function separately).\n\t\tfactory(root);\n\t}\n}(typeof global != 'undefined' ? global : this, function(root) {\n\n\tif (root.CSS && root.CSS.escape) {\n\t\treturn root.CSS.escape;\n\t}\n\n\t// https://drafts.csswg.org/cssom/#serialize-an-identifier\n\tvar cssEscape = function(value) {\n\t\tif (arguments.length == 0) {\n\t\t\tthrow new TypeError('`CSS.escape` requires an argument.');\n\t\t}\n\t\tvar string = String(value);\n\t\tvar length = string.length;\n\t\tvar index = -1;\n\t\tvar codeUnit;\n\t\tvar result = '';\n\t\tvar firstCodeUnit = string.charCodeAt(0);\n\t\twhile (++index < length) {\n\t\t\tcodeUnit = string.charCodeAt(index);\n\t\t\t// Note: theres no need to special-case astral symbols, surrogate\n\t\t\t// pairs, or lone surrogates.\n\n\t\t\t// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER\n\t\t\t// (U+FFFD).\n\t\t\tif (codeUnit == 0x0000) {\n\t\t\t\tresult += '\\uFFFD';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n\t\t\t\t// U+007F, []\n\t\t\t\t(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||\n\t\t\t\t// If the character is the first character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039), []\n\t\t\t\t(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||\n\t\t\t\t// If the character is the second character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039) and the first character is a `-` (U+002D), []\n\t\t\t\t(\n\t\t\t\t\tindex == 1 &&\n\t\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 &&\n\t\t\t\t\tfirstCodeUnit == 0x002D\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n\t\t\t\tresult += '\\\\' + codeUnit.toString(16) + ' ';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is the first character and is a `-` (U+002D), and\n\t\t\t\t// there is no second character, []\n\t\t\t\tindex == 0 &&\n\t\t\t\tlength == 1 &&\n\t\t\t\tcodeUnit == 0x002D\n\t\t\t) {\n\t\t\t\tresult += '\\\\' + string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the character is not handled by one of the above rules and is\n\t\t\t// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or\n\t\t\t// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to\n\t\t\t// U+005A), or [a-z] (U+0061 to U+007A), []\n\t\t\tif (\n\t\t\t\tcodeUnit >= 0x0080 ||\n\t\t\t\tcodeUnit == 0x002D ||\n\t\t\t\tcodeUnit == 0x005F ||\n\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 ||\n\t\t\t\tcodeUnit >= 0x0041 && codeUnit <= 0x005A ||\n\t\t\t\tcodeUnit >= 0x0061 && codeUnit <= 0x007A\n\t\t\t) {\n\t\t\t\t// the character itself\n\t\t\t\tresult += string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Otherwise, the escaped character.\n\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character\n\t\t\tresult += '\\\\' + string.charAt(index);\n\n\t\t}\n\t\treturn result;\n\t};\n\n\tif (!root.CSS) {\n\t\troot.CSS = {};\n\t}\n\n\troot.CSS.escape = cssEscape;\n\treturn cssEscape;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css.escape/css.escape.js\n// module id = 4\n// module chunks = 0","module.exports = \"<!-- Bubble Chart Component -->\\n<div class=\\\"vzb-bubblechart\\\">\\n    <svg class=\\\"vzb-bubblechart-svg vzb-export\\\">\\n        <g class=\\\"vzb-bc-graph\\\">\\n            <g class=\\\"vzb-bc-year\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-axis-x\\\"><g></g></svg>\\n            <svg class=\\\"vzb-bc-axis-y\\\"><g></g></svg>\\n            <line class=\\\"vzb-bc-projection-x\\\"></line>\\n            <line class=\\\"vzb-bc-projection-y\\\"></line>\\n\\n            <svg class=\\\"vzb-bc-bubbles-crop\\\">\\n                <g class=\\\"vzb-zoom-selection\\\"></g>\\n                <line class=\\\"vzb-bc-line-equal-xy vzb-invisible\\\"></line>\\n                <rect class=\\\"vzb-bc-eventarea\\\"></rect>\\n                <g class=\\\"vzb-bc-trails\\\"></g>\\n                <g class=\\\"vzb-bc-bubbles\\\"></g>\\n                <g class=\\\"vzb-bc-lines\\\"></g>\\n                <g class=\\\"vzb-bc-bubble-crown vzb-hidden\\\">\\n                    <circle class=\\\"vzb-crown-glow\\\"></circle>\\n                    <circle class=\\\"vzb-crown\\\"></circle>\\n                </g>\\n            </svg>\\n\\n            <g class=\\\"vzb-bc-axis-y-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-s-title\\\"></g>\\n            <g class=\\\"vzb-bc-axis-c-title\\\"></g>\\n\\n            <g class=\\\"vzb-bc-axis-y-info vzb-noexport\\\"></g>\\n            <g class=\\\"vzb-bc-axis-x-info vzb-noexport\\\"></g>\\n\\n            <svg class=\\\"vzb-bc-labels-crop\\\">\\n                <g class=\\\"vzb-bc-labels\\\"></g>\\n            </svg>\\n\\n            <g class=\\\"vzb-data-warning vzb-noexport\\\">\\n                <svg></svg>\\n                <text></text>\\n            </g>\\n\\n            <rect class=\\\"vzb-bc-zoom-rect\\\"></rect>\\n            <g class=\\\"vzb-bc-tooltip vzb-hidden\\\">\\n                <rect class=\\\"vzb-tooltip-glow\\\"></rect>\\n                <rect class=\\\"vzb-tooltip-border\\\"></rect>\\n                <text class=\\\"vzb-tooltip-text\\\"></text>\\n            </g>\\n        </g>\\n    </svg>\\n    <svg>\\n        <defs>\\n            <filter id=\\\"vzb-glow-filter\\\" x=\\\"-50%\\\" y=\\\"-50%\\\" width=\\\"200%\\\" height=\\\"200%\\\">\\n                <feGaussianBlur in=\\\"SourceGraphic\\\" stdDeviation=\\\"2\\\"></feGaussianBlur>\\n            </filter>\\n        </defs>\\n    </svg>\\n    <!-- This could possibly be another component -->\\n    <div class=\\\"vzb-tooltip vzb-hidden vzb-tooltip-mobile\\\"></div>\\n</div>\\n\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/template.html\n// module id = 6\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}